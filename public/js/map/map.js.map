{"version":3,"sources":["client/js/map/browsesLayer.js","client/js/map/degreeConvertor.js","client/js/map/gazetteer.js","client/js/map/geojsonconverter.js","client/js/map/globweb.js","client/js/map/handler.js","client/js/map/layerImport.js","client/js/map/map.js","client/js/map/openlayers.js","client/js/map/polygonHandler.js","client/js/map/rectangle.js","client/js/map/rectangleHandler.js","client/js/map/selectHandler.js","client/js/map/utils.js","client/js/map/vector3d.js","client/js/map/widget/background.js","client/js/map/widget/layers.js","client/js/map/widget/mapPopup.js","client/js/map/widget/toolbarMap.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxKA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjDA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5IA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArhBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApFA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1hBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjkBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhJA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArFA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArOA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxTA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAndA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlPA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjFA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhHA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxUA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1DA;AAAA","file":"../ngEO-LWS/public/js/map/map.js","sourcesContent":["/**\r\n * Browses layer module\r\n */\r\n\r\nvar Configuration = require('configuration');\r\nvar MapUtils = require('map/utils');\r\n\r\n// Helper function to format the numbers in range [0,9] by adding \"0\" before\r\nvar pad2 = function(num) {\r\n    var s = num + \"\";\r\n    if (s.length < 2) s = \"0\" + s;\r\n    return s;\r\n}\r\n\r\n// Helper function to convert a date to an iso string, only the date part\r\nvar toWMTSTime = function(date) {\r\n\treturn date.getUTCFullYear() + \"-\" + pad2(date.getUTCMonth()+1) + \"-\" + pad2(date.getUTCDate()) + \"T\" + pad2(date.getUTCHours()) + \":\" + pad2(date.getUTCMinutes()) + \":\" + pad2(date.getUTCSeconds()) + \"Z\";\r\n};\r\n\r\n/**\r\n *\tContainer of browses\r\n */\r\nvar BrowsesLayer = function(params, mapEngine) {\r\n\tthis.params = params;\r\n\t\r\n\t// A map between feature id and internal browse layer\r\n\tvar browseLayersMap = {};\r\n\t// The array of browse layers\r\n\tvar browseLayers = [];\r\n\t\r\n\t/**\r\n\t * Change visibility of browse layers\r\n\t */\r\n\tthis.setVisible = function(vis) {\r\n\t\tthis.params.visible = vis;\r\n\t\tfor ( var i = 0; i < browseLayers.length; i++ ) {\r\n\t\t\tbrowseLayers[i].params.visible = vis;\r\n\t\t\tmapEngine.setLayerVisible(browseLayers[i].engineLayer,vis);\r\n\t\t}\r\n\r\n\t\t// HACK: Load Map dynamically to avoid circular dependency\r\n\t\tvar Map = require('map/map');\r\n\t\tMap.trigger(\"visibility:changed\", this);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Clear the  browse layers\r\n\t */\r\n\tthis.clear = function() {\r\n\t\tfor ( var i = 0; i < browseLayers.length; i++ ) {\r\n\t\t\tmapEngine.removeLayer(browseLayers[i].engineLayer);\r\n\t\t}\r\n\t\tbrowseLayersMap = {};\r\n\t\tbrowseLayers = [];\r\n\t};\r\n\t\r\n\t/**\r\n\t * Add features to layer\r\n\t */\r\n\tthis.addBrowse = function(feature, browseUrl) {\r\n\t\tif (!browseLayersMap.hasOwnProperty(browseUrl)) {\r\n\t\t\t// Set browseUrl in map to mark the creation of browse to avoid double creating of\r\n\t\t\t// browse provoked by highlight event as well..\r\n\t\t\tbrowseLayersMap[browseUrl] = browseUrl;\r\n\t\t\t\r\n\t\t\tvar layerDesc = MapUtils.createWmsLayerFromUrl(browseUrl);\r\n\t\t\tif ( !layerDesc.params.time ) {\r\n\t\t\t\t// Take the time from feature if no time has been defined in url\r\n\t\t\t\t// Fix NGEO-1031 : remove milliseconds from date\r\n\t\t\t\tvar begin = Date.fromISOString(Configuration.getMappedProperty( feature, \"start\" ));\r\n\t\t\t\tbegin.setUTCMilliseconds(0);\r\n\t\t\t\tvar end = Date.fromISOString(Configuration.getMappedProperty( feature, \"stop\" ));\r\n\t\t\t\tend.setUTCMilliseconds(0);\r\n\t\t\t\tlayerDesc.params.time = toWMTSTime(begin) + \"/\" + toWMTSTime(end);\r\n\t\t\t}\r\n\r\n\t\t\tif ( layerDesc.type.toUpperCase() == \"WMTS\" && !layerDesc.params.matrixSet ) {\r\n\t\t\t\t// If no matrixSet is defined, take ones from configuration\r\n\t\t\t\tvar mapProjection = Configuration.get('map.projection', \"EPSG:4326\");\r\n\t\t\t\tvar wmtsMap = Configuration.get('browseDisplay.wmtsParameters', {\r\n\t\t\t\t\t\"EPSG:4326\": {\r\n\t\t\t\t\t\t\"params\" : {\r\n\t\t\t\t\t\t\t\"matrixSet\": \"WGS84\"\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\t\"EPSG:3857\": {\r\n\t\t\t\t\t\t\"params\": {\r\n\t\t\t\t\t\t\t\"matrixSet\": \"g\"\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tlayerDesc.projection = mapProjection;\r\n\t\t\t\tlayerDesc.params.matrixSet = wmtsMap[mapProjection].params.matrixSet;\r\n\t\t\t}\r\n\t\t\tMapUtils.computeExtent(feature);\r\n\r\n\t\t\t// Update some WEBC intrinsic values which couldn't be extracted from browse url\r\n\t\t\t_.merge(layerDesc, {\r\n\t\t\t\tname: browseUrl,\r\n\t\t\t\tvisible: this.params.visible,\r\n\t\t\t\topacity: Configuration.get(\"map.browseDisplay.opacity\", 1.0),\r\n\t\t\t\tbbox: feature.bbox,\r\n\t\t\t\tcrossOrigin: Configuration.get(\"map.browseDisplay.crossOrigin\", \"anonymous\")\r\n\t\t\t});\r\n\t\t\tlayerDesc.params.transparent = true;\r\n\r\n\t\t\tvar browseLayerDesc = {\r\n\t\t\t\ttime:  Configuration.getMappedProperty( feature, \"stop\" ),\r\n\t\t\t\tparams: layerDesc.params,\r\n\t\t\t\tengineLayer: mapEngine.addLayer(layerDesc)\r\n\t\t\t};\r\n\r\n\t\t\t// Finally set the real browseLayerDesc in browseLayerMap\r\n\t\t\tbrowseLayersMap[browseUrl] = browseLayerDesc;\r\n\t\t\tbrowseLayers.push( browseLayerDesc );\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Remove browse from layer\r\n\t *\r\n\t * @param id\r\n\t *\t\tBrowse url\r\n\t */\r\n\tthis.removeBrowse = function(browseUrl)  {\r\n\t\t// Remove the WMS only if it does exists\r\n\t\tif (browseLayersMap.hasOwnProperty(browseUrl)) {\r\n\t\t\r\n\t\t\t// Get the browse layer structure from the map\r\n\t\t\tvar bl = browseLayersMap[ browseUrl ];\r\n\t\t\t\r\n\t\t\t// Delete it\r\n\t\t\tdelete browseLayersMap[ browseUrl ];\r\n\t\t\t\r\n\t\t\t// Remove browse layer from the current engine\r\n\t\t\tmapEngine.removeLayer(bl.engineLayer);\r\n\t\t\t\r\n\t\t\t// Remove from array\r\n\t\t\tbrowseLayers.splice( browseLayers.indexOf(bl), 1 );\r\n\t\t}\r\n\t};\r\n\t\r\n\tthis.isEmpty = function() {\r\n\t\treturn browseLayers.length == 0;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Change engine\r\n\t */\r\n\tthis.changeEngine = function(me) {\r\n\t\tmapEngine = me;\r\n\t\tfor ( var i = 0; i < browseLayers.length; i++ ) {\r\n\t\t\tbrowseLayers[i].engineLayer = mapEngine.addLayer( browseLayers[i].params );\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t *\tBrowses getter\r\n\t */\r\n\tthis.getBrowses = function() {\r\n\t\treturn browseLayers;\r\n\t}\r\n};\r\n\r\nmodule.exports = BrowsesLayer;\r\n\r\n\r\n\r\n","/**\n * Utility module to convert decimal degree to degree/minute/second and vice versa.\n */\nmodule.exports = {\n\t/**\n\t * Utility method to convert coordinates from decimal degree to\n\t * degree/minute/second.\n\t * \n\t * @param dd\n\t *            coordinates in decimal degrees\n\t * @param isLon\n\t *            flag indicating if coordinates is on longitude or not\n\t * @return coordinates in degree/minute/second\n\t */\n\ttoDMS: function(dd, isLon, sep) {\n\t\tvar positionFlag = \"\";\n\t\tif (isLon) {\n\t\t\tpositionFlag = (dd >= 0) ? \"E\" : \"W\";\n\t\t} else {\n\t\t\tpositionFlag = (dd >= 0) ? \"N\" : \"S\";\n\t\t}\n\n\t\tvar deg = dd | 0; // truncate dd to get degrees\n\t\tvar frac = Math.abs(dd - deg); // get fractional part\n\t\tvar min = (frac * 60) | 0; // multiply fraction by 60 and truncate\n\t\tvar sec = (frac * 3600 - min * 60) | 0;\n\t\treturn Math.abs(deg) + (sep || \"째\") + min + (sep || \"'\") + sec + (sep || '\"') + positionFlag;\n\t},\n\n\t/**\n\t * Utility method to convert coordinate from degree/minute/second to\n\t * decimal degrees.\n\t * \n\t * @param dms\n\t *            coordinate in degree/minute/second\n\t * @return coordinate in decimal degrees.\n\t */\n\ttoDecimalDegrees: function(dms) {\n\t\tvar dmsRe = /^\\s*(\\d+)째(\\d+)'(\\d+)\"([EWNS]{1})\\s*$/;\n\t\tvar match = dmsRe.exec(dms);\n\n\t\tif (match) {\n\n\t\t\tvar coordinate = parseFloat(match[1]) + (parseFloat(match[2]) / 60.0) + (parseFloat(match[3]) / 3600.0);\n\t\t\tcoordinate *= (match[4] == 'W' || match[4] == 'S') ? -1.0 : 1.0;\n\n\t\t\treturn coordinate;\n\t\t} else {\n\t\t\treturn Number.NaN;\n\t\t}\n\t},\n\n\t/**\n\t * Utility method to convert coordinates from text in degree/minute/second to array of decimal\n\t * degrees coordinates.\n\t * \n\t * @param dms\n\t *            text containing coordinates in degree/minute/second\n\t * @return array of coordinates extracted from DMS text. Empty array if regexp don't found match. \n\t */\n\ttextToDecimalDegrees: function(text) {\n\t\tvar coordinates = [];\n\t\tvar polygonRe = /\\s*(\\d+)째(\\d+)'(\\d+)\"([EW]{1})\\s+(\\d+)째(\\d+)'(\\d+)\"([NS]){1}/gm;\n\t\tvar match = polygonRe.exec(text);\n\n\t\twhile (match) {\n\t\t\tvar lon = parseFloat(match[1]) + (parseFloat(match[2]) / 60.0) + (parseFloat(match[3]) / 3600.0);\n\t\t\tvar lat = parseFloat(match[5]) + (parseFloat(match[6]) / 60.0) + (parseFloat(match[7]) / 3600.0);\n\t\t\tlon *= (match[4] == 'W') ? -1.0 : 1.0;\n\t\t\tlat *= (match[8] == 'S') ? -1.0 : 1.0;\n\t\t\tcoordinates.push([lon, lat]);\n\t\t\tmatch = polygonRe.exec(text);\n\t\t}\n\n\t\treturn coordinates;\n\t}\n};","/**\r\n * Gazetteer module.\r\n * The function to define the Gazetteer module\r\n */\r\n\r\n\r\nvar Configuration = require('configuration');\r\n\r\n/**\r\n * Private function\r\n */\r\n\r\n/**\r\n * Public interface\r\n */\r\nmodule.exports = {\r\n\r\n\t/**\r\n\t * Query the gazetter and return the result in a callback\r\n\t */\r\n\tquery: function(options) {\r\n\r\n\t\tvar queryUrl = 'https://nominatim.openstreetmap.org/search?';\r\n\t\tqueryUrl += 'q=' + encodeURIComponent(options.query);\r\n\t\tqueryUrl += '&format=json';\r\n\t\tif (Configuration.data.gazetteer.outputPolygon) {\r\n\t\t\tqueryUrl += '&polygon_text=1';\r\n\t\t}\r\n\t\tqueryUrl += '&limit=' + Configuration.data.gazetteer.maxResults;\r\n\r\n\t\t$.ajax({\r\n\t\t\turl: queryUrl,\r\n\t\t\tdataType: 'jsonp',\r\n\t\t\tjsonp: 'json_callback',\r\n\t\t\ttimeout: Configuration.data.gazetteer.timeout, // Timeout is needed to have an error callback\r\n\t\t\tsuccess: function(data) {\r\n\t\t\t\tif (options.result) {\r\n\t\t\t\t\toptions.result(data);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\terror: function() {\r\n\t\t\t\tif (options.result) {\r\n\t\t\t\t\toptions.result([]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t},\r\n\r\n};","/**\n * GeoJsonConverter based on OpenLayers\n */\n\n//require('OpenLayers.min');\n\n\n// Use to convert to GeoJSON \nvar geoJsonFormat = new OpenLayers.Format.GeoJSON();\n\n/*!\n * Convert a OpenLayer.Feature object to GeoJSON\n * @return a GeoJSON feature collection\n */\nvar _convertOL = function(features) {\n\tif (features && features.length > 0) {\n\t\tvar json = geoJsonFormat.write(features);\n\t\treturn JSON.parse(json);\n\t}\n};\n\n/**\n * Public interface for GeoJsonConverter\n */\nmodule.exports = {\n\t/*!\n\t * Load layer data into GeoJSON\n\t * @param layer the layer to load\n\t * @param onload the callback to call when all data is loaded\n\t */\n\tload: function(layer, onload) {\n\n\t\t// Create OpenLayers protocol according to its type\n\t\tvar protocol;\n\t\tswitch (layer.type) {\n\t\t\tcase \"GeoRSS\":\n\t\t\t\tprotocol = new OpenLayers.Protocol.HTTP({\n\t\t\t\t\turl: layer.location,\n\t\t\t\t\tformat: new OpenLayers.Format.GeoRSS()\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"WFS\":\n\t\t\t\tprotocol = new OpenLayers.Protocol.WFS({\n\t\t\t\t\turl: layer.baseUrl,\n\t\t\t\t\tfeatureType: layer.featureType,\n\t\t\t\t\tfeatureNS: layer.featureNS\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// If protocol exists, call it to load data\n\t\tif (protocol) {\n\t\t\tprotocol.read({\n\t\t\t\tcallback: function(resp) {\n\t\t\t\t\tif (resp.features) {\n\t\t\t\t\t\tonload(_convertOL(resp.features));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t/*!\n\t * Convert GeoJSON features to any format\n\t *\n\t * @param features the features to convert\n\t * @param format the format\n\t *\n\t * @return the data as a string\n\t */\n\tconvert: function(features, format) {\n\t\tvar f = format.toUpperCase();\n\n\t\tvar fc = {\n\t\t\ttype: 'FeatureCollection',\n\t\t\tfeatures: features\n\t\t};\n\n\t\tswitch (f) {\n\t\t\tcase \"KML\":\n\t\t\t\t// Convert to OpenLayers\n\t\t\t\tvar olFeatures = geoJsonFormat.read(fc);\n\t\t\t\tvar kmlFormat = new OpenLayers.Format.KML();\n\t\t\t\treturn kmlFormat.write(olFeatures);\n\t\t\t\tbreak;\n\t\t\tcase \"GML\":\n\t\t\t\tvar olFeatures = geoJsonFormat.read(fc);\n\t\t\t\tvar gmlFormat = new OpenLayers.Format.GML();\n\t\t\t\treturn gmlFormat.write(olFeatures);\n\t\t\t\tbreak;\n\t\t\tcase \"JSON\":\n\t\t\tcase \"GEOJSON\":\n\t\t\t\treturn JSON.stringify(fc);\n\t\t}\n\t},\n\n\t/*!\n\t * Convert a vector layer to GeoJSON\n\t * The layer data is converted to GeoJSON\n\t *\n\t * @param layer the layer to convert\n\t *\n\t * @return if the function succeeds\n\t */\n\ttoGeoJSON: function(layer) {\n\t\tif (!layer.data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar features;\n\t\tswitch (layer.type.toUpperCase()) {\n\t\t\tcase \"KML\":\n\t\t\t\tvar kmlFormat = new OpenLayers.Format.KML({\n\t\t\t\t\textractStyles: true,\n\t\t\t\t\textractAttributes: true,\n\t\t\t\t\tmaxDepth: 0\n\t\t\t\t});\n\t\t\t\tfeatures = kmlFormat.read(layer.data);\n\t\t\t\tbreak;\n\t\t\tcase \"GML\":\n\t\t\t\tvar gmlFormat = new OpenLayers.Format.GML();\n\t\t\t\tfeatures = gmlFormat.read(layer.data);\n\t\t\t\tbreak;\n\t\t\tcase \"JSON\":\n\t\t\tcase \"GEOJSON\":\n\t\t\t\tif (typeof layer.data == \"string\") {\n\t\t\t\t\tlayer.data = JSON.parse(layer.data);\n\t\t\t\t}\n\t\t\t\tlayer.type = 'GeoJSON';\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif (features && features.length > 0) {\n\t\t\tlayer.data = _convertOL(features);\n\t\t\tlayer.type = 'GeoJSON';\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n};","/**\n * GlobWeb map engine\n */\n\n\nvar Configuration = require('configuration');\nvar GeojsonConverter = require('map/geojsonconverter');\n//require('GlobWeb.min');\n\nvar baseZIndex = 365; // \"Magic number\" to make WMS/WMTS always on top\n\n/**\n * GlobeWeb Map Engine constructor\n * parentElement : the parent element div for the map\n */\nGlobWebMapEngine = function(parentElement) {\n\tthis.groundOverlays = {};\n\tthis.features = {};\n\tthis.styles = {};\n\tthis.parentElement = parentElement;\n\tthis.nbAddedOverlays = 0;\n\n\ttry {\n\t\t// Create the canvas element\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.id = \"map\";\n\t\tcanvas.width = parentElement.clientWidth;\n\t\tcanvas.height = parentElement.clientHeight;\n\t\tparentElement.appendChild(canvas);\n\t\tthis.canvas = canvas;\n\n\t\t// Create element to show attributions\n\t\tvar attributions = document.createElement('div');\n\t\tattributions.id = \"attributions\";\n\t\tattributions.className = \"olControlAttribution\"; // Use existing openlayers CSS rules\n\t\tparentElement.appendChild(attributions)\n\t\tthis.attributions = attributions;\n\n\t\t// Create the globe\n\t\tvar globe = new GlobWeb.Globe({\n\t\t\tcanvas: canvas,\n\t\t\ttileErrorTreshold: Configuration.get('map.globweb.tileErrorTreshold', 2),\n\t\t\tcontinuousRendering: Configuration.get('map.globweb.continuousRendering', false)\n\t\t});\n\n\t\t// Add attribution handler\n\t\tnew GlobWeb.AttributionHandler(globe, {\n\t\t\telement: 'attributions'\n\t\t});\n\n\t\tvar elevationParams = Configuration.get('map.globweb.elevationLayer');\n\t\tif (elevationParams) {\n\t\t\tvar elevationLayer = new GlobWeb.WCSElevationLayer(elevationParams);\n\t\t\tglobe.setBaseElevation(elevationLayer);\n\t\t}\n\n\t\t// Display some stats\n\t\tif (Configuration.get('map.globweb.displayStats', false)) {\n\t\t\tthis.stats = document.createElement('div');\n\t\t\tthis.stats.id = \"stats\";\n\t\t\tparentElement.appendChild(this.stats);\n\t\t\tnew GlobWeb.Stats(globe, {\n\t\t\t\telement: this.stats,\n\t\t\t\tverbose: true\n\t\t\t});\n\t\t}\n\n\t\t// Create the loading element\n\t\tthis.$loading = $('<img src=\"../css/images/ajax-loader.gif\" id=\"loading\"></img>')\n\t\t\t.appendTo(parentElement);\n\n\t\tglobe.subscribe(\"baseLayersReady\", function() {\n\t\t\t$(\"#loading\").hide();\n\t\t});\n\n\t\t// Add mouse navigation\n\t\tvar navigation = new GlobWeb.Navigation(globe, {\n\t\t\tmouse: {\n\t\t\t\tzoomOnDblClick: false\n\t\t\t},\n\t\t\tzoomDuration: Configuration.get('map.globweb.zoomDuration', 500)\n\t\t});\n\t\t\n\t\t// Used for debug\n\t\t// globe.addLayer(new GlobWeb.TileWireframeLayer({outline: true}));\n\n\t\tthis.globe = globe;\n\t\tthis.navigation = navigation;\n\t} catch (err) {\n\t\tparentElement.removeChild(canvas);\n\t\tparentElement.removeChild(attributions);\n\t\tthis.canvas = null;\n\t\tthis.attributions = null;\n\t\tconsole.log(\"WebGL cannot be initialized.\")\n\t\tthrow 'WebGLNotFound';\n\t}\n}\n\nvar createGWStyle = function(style) {\n\tvar gwStyle = new GlobWeb.FeatureStyle(style);\n\n\tif (style.strokeColor) {\n\t\tgwStyle.strokeColor = GlobWeb.FeatureStyle.fromStringToColor(style.strokeColor);\n\t}\n\n\treturn gwStyle;\n};\n\n/** \n *  Create conditional GlobWeb styles from configuration\n *  @see For more details see NGEO-2222 \n */ \nGlobWebMapEngine.prototype.createConditionalStyles = function(baseStyle, condStyle) {\n\tvar styleHints = ['default', 'select', 'highlight', 'highlight-select'];\n\t_.each(styleHints, function(styleHint) {\n\t\tif ( condStyle[styleHint] ) {\n\t\t\tvar s = createGWStyle(condStyle[styleHint]);\n\t\t\ts.isApplicable = function(feature, style) {\n\t\t\t\treturn style == styleHint && Configuration.getFromPath(feature, condStyle.attribute) == condStyle.value;\n\t\t\t}\n\t\t\tbaseStyle[condStyle.attribute+\"-\"+condStyle.value+\"-\"+styleHint] = s;\n\t\t}\n\t} );\n}\n\n/**\n * Add a style\n */\nGlobWebMapEngine.prototype.addStyle = function(name, style) {\n\n\tvar gwStyle = {};\n\n\tif (style['default'] || name == \"lut\") {\n\t\t// It's a style map\n\t\tfor (var x in style) {\n\t\t\tif ( x == \"conditionals\" ) {\n\t\t\t\tfor (var i=0; i<style[x].length; i++) {\n\t\t\t\t\tthis.createConditionalStyles(gwStyle, style[x][i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (style.hasOwnProperty(x)) {\n\t\t\t\t\tgwStyle[x] = createGWStyle(style[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// It's a simple style description\n\t\tgwStyle['default'] = createGWStyle(style);\n\t}\n\n\tthis.styles[name] = gwStyle;\n};\n\n/**\n * Set the background layer\n */\nGlobWebMapEngine.prototype.setBackgroundLayer = function(layer) {\n\n\tvar gwLayer;\n\n\tswitch (layer.type.toUpperCase()) {\n\t\tcase \"OSM\":\n\t\t\tgwLayer = new GlobWeb.OSMLayer(layer);\n\t\t\tbreak;\n\t\tcase \"WMS\":\n\t\t\tgwLayer = new GlobWeb.WMSLayer($.extend({\n\t\t\t\t\tname: layer.name,\n\t\t\t\t\tbaseUrl: layer.baseUrl,\n\t\t\t\t\tprojection: layer.projection,\n\t\t\t\t\tcrossOrigin: layer.crossOrigin,\n\t\t\t\t\tattribution: layer.attribution\n\t\t\t\t},\n\t\t\t\tlayer.params));\n\t\t\tbreak;\n\t\tcase \"WMTS\":\n\t\t\tgwLayer = new GlobWeb.WMTSLayer($.extend({\n\t\t\t\t\tname: layer.name,\n\t\t\t\t\tbaseUrl: layer.baseUrl,\n\t\t\t\t\tprojection: layer.projection,\n\t\t\t\t\tcrossOrigin: layer.crossOrigin,\n\t\t\t\t\tattribution: layer.attribution,\n\t\t\t\t\tlayer: layer.params.layer,\n\t\t\t\t\tmatrixSet: layer.params.matrixSet,\n\t\t\t\t\tstartLevel: layer.projection == \"EPSG:4326\" ? 1 : 0\n\t\t\t\t},\n\t\t\t\tlayer.params));\n\t\t\tbreak;\n\t\tcase \"BING\":\n\t\t\tgwLayer = new GlobWeb.BingLayer(layer);\n\t\t\tbreak;\n\t}\n\n\tif (gwLayer)\n\t\tthis.globe.setBaseImagery(gwLayer);\n\n\tthis.$loading.show();\n\n\treturn gwLayer;\n}\n\n/**\n * Set layer visibility\n */\nGlobWebMapEngine.prototype.setLayerVisible = function(gwLayer, vis) {\n\tgwLayer.visible(vis);\n}\n\n/**\n * Set layer index\n */\nGlobWebMapEngine.prototype.setLayerIndex = function(gwLayer, index) {\n\tgwLayer.zIndex = index;\n\t// Update stylemap to update vector layer z-index ordering\n\tfor ( var x in gwLayer.styleMap ) {\n\t\tgwLayer.styleMap[x].zIndex = index;\n\t}\n}\n\n/**\n * Add a layer\n */\nGlobWebMapEngine.prototype.addLayer = function(layer) {\n\n\tvar gwLayer;\n\tswitch (layer.type.toUpperCase()) {\n\t\tcase \"WMS\":\n\t\t\tgwLayer = new GlobWeb.WMSLayer($.extend({\n\t\t\t\tname: layer.name,\n\t\t\t\tbaseUrl: layer.baseUrl,\n\t\t\t\tprojection: layer.projection,\n\t\t\t\tcrossOrigin: layer.crossOrigin\n\t\t\t}, layer.params));\n\t\t\tbreak;\n\t\tcase \"WMTS\":\n\t\t\tvar config = {\n\t\t\t\tname: layer.name,\n\t\t\t\tbaseUrl: layer.baseUrl,\n\t\t\t\tstyle: layer.params.style,\n\t\t\t\tlayer: layer.params.layer,\n\t\t\t\tprojection: layer.projection,\n\t\t\t\tformat: layer.params.format,\n\t\t\t\tmatrixSet: layer.params.matrixSet,\n\t\t\t\tstartLevel: layer.projection == \"EPSG:4326\" ? 1 : 0,\n\t\t\t\ttime: layer.params.time,\n\t\t\t\tcrossOrigin: layer.crossOrigin\n\t\t\t};\n\t\t\tif (layer.bbox) {\n\t\t\t\tconfig.geoBound = new GlobWeb.GeoBound(layer.bbox[0], layer.bbox[1], layer.bbox[2], layer.bbox[3]);\n\t\t\t}\n\t\t\tgwLayer = new GlobWeb.WMTSLayer(config);\n\t\t\tbreak;\n\t\tcase \"FEATURE\":\n\t\tcase \"JSON\":\n\t\tcase \"GEOJSON\":\n\t\t\tgwLayer = new GlobWeb.VectorLayer({\n\t\t\t\tname: layer.name,\n\t\t\t\tvisible: layer.visible\n\t\t\t});\n\t\t\tif (layer.data) {\n\t\t\t\tif (typeof layer.data == \"string\") {\n\t\t\t\t\tthis.addFeature(gwLayer, JSON.parse(layer.data));\n\t\t\t\t} else {\n\t\t\t\t\tthis.addFeature(gwLayer, layer.data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"WFS\":\n\t\tcase \"GEORSS\":\n\t\t\tgwLayer = new GlobWeb.VectorLayer({\n\t\t\t\tname: layer.name,\n\t\t\t\tvisible: layer.visible,\n\t\t\t\tattribution: layer.attribution,\n\t\t\t\tstyle: new GlobWeb.FeatureStyle({\n\t\t\t\t\ticonUrl: '../images/point.png',\n\t\t\t\t\tpointMaxSize: 40000\n\t\t\t\t})\n\t\t\t});\n\t\t\tGeojsonConverter.load(layer, $.proxy(gwLayer.addFeatureCollection, gwLayer));\n\t\t\tbreak;\n\t\tcase \"KML\":\n\t\t\tgwLayer = new GlobWeb.VectorLayer(layer);\n\t\t\t$.get(layer.location, function(data) {\n\t\t\t\tvar features = GlobWeb.KMLParser.parse(data);\n\t\t\t\tgwLayer.addFeatureCollection(features);\n\t\t\t});\n\t\t\tbreak;\n\t}\n\n\tif (gwLayer) {\n\t\tif (layer.style && this.styles.hasOwnProperty(layer.style)) {\n\t\t\tgwLayer.style = this.styles[layer.style]['default'];\n\t\t\tgwLayer.styleMap = _.extend({}, this.styles[\"lut\"], this.styles[layer.style]);\n\t\t}\n\t\t\n\t\t// NGEO-1779: Set zIndex to be always on top for overlay WMS/WMTS\n\t\tif ( layer.type.toUpperCase() == \"WMS\" || layer.type.toUpperCase() == \"WMTS\" ) {\n\t\t\tgwLayer.zIndex = baseZIndex + this.nbAddedOverlays;\n\t\t\tthis.nbAddedOverlays++;\n\t\t}\n\n\t\tgwLayer.visible(layer.visible);\n\t\tthis.globe.addLayer(gwLayer);\n\t}\n\n\treturn gwLayer;\n}\n\n/**\n * Remove layer from the map engine\n */\nGlobWebMapEngine.prototype.removeLayer = function(gwLayer) {\n\tthis.globe.removeLayer(gwLayer);\n\tif ( gwLayer instanceof GlobWeb.WMTSLayer || gwLayer instanceof GlobWeb.WMSLayer ) {\n\t\tthis.nbAddedOverlays--;\n\t}\n}\n\n/**\n * Subscribe to GlobWebMap events\n */\nGlobWebMapEngine.prototype.subscribe = function(name, callback) {\n\tswitch (name) {\n\t\tcase \"init\":\n\t\t\tcallback(this);\n\t\t\tbreak;\n\t\tcase \"navigationModified\":\n\t\t\tthis.navigation.subscribe(\"modified\", callback);\n\t\t\tbreak;\n\t\tcase \"mousedown\":\n\t\tcase \"mousemove\":\n\t\tcase \"mouseup\":\n\t\tcase \"click\":\n\t\tcase \"dblclick\":\n\t\t\tthis.canvas.addEventListener(name, callback);\n\t\t\tbreak;\n\t}\n}\n\n/**\n * Unsubscribe to GlobWebMap events\n */\nGlobWebMapEngine.prototype.unsubscribe = function(name, callback) {\n\tswitch (name) {\n\t\tcase \"startNavigation\":\n\t\t\tthis.globe.unsubscribe(\"startNavigation\", callback);\n\t\t\tbreak;\n\t\tcase \"endNavigation\":\n\t\t\tthis.globe.unsubscribe(\"endNavigation\", callback);\n\t\t\tbreak;\n\t\tcase \"mousedown\":\n\t\tcase \"mousemove\":\n\t\tcase \"mouseup\":\n\t\tcase \"click\":\n\t\tcase \"dblclick\":\n\t\t\tthis.canvas.removeEventListener(name, callback);\n\t\t\tbreak;\n\t}\n}\n\n/**\n * Update the size of the map\n */\nGlobWebMapEngine.prototype.updateSize = function() {\n\tthis.canvas.width = this.parentElement.clientWidth;\n\tthis.canvas.height = this.parentElement.clientHeight;\n\tthis.globe.refresh();\n}\n\n/**\n * Get lon lat from pixel\n */\nGlobWebMapEngine.prototype.getLonLatFromPixel = function(x, y) {\n\tvar pt = this.globe.getLonLatFromPixel(x, y);\n\tif (pt) {\n\t\t// To be compliant with OpenLayers remove Z\n\t\tpt.length = 2;\n\t}\n\treturn pt;\n}\n\n/**\n * Get pixel from lonlat\n */\nGlobWebMapEngine.prototype.getPixelFromLonLat = function(lon, lat) {\n\tvar pixel = this.globe.getPixelFromLonLat(lon, lat);\n\treturn {\n\t\tx: pixel[0],\n\t\ty: pixel[1]\n\t};\n}\n\n\n/**\n * Get the current viewport extent\n */\nGlobWebMapEngine.prototype.getViewportExtent = function() {\n\t// TODO : improve geobound\n\tvar geoBound = this.globe.getViewportGeoBound();\n\tif (geoBound)\n\t\treturn [geoBound.getWest(), geoBound.getSouth(), geoBound.getEast(), geoBound.getNorth()];\n\n\treturn [-180, -90, 180, 90];\n}\n\n/**\n * Zoom in\n */\nGlobWebMapEngine.prototype.zoomIn = function() {\n\tthis.navigation.zoom(-2);\n\tthis.globe.refresh();\n}\n\n/**\n * Zoom out\n */\nGlobWebMapEngine.prototype.zoomOut = function() {\n\tthis.navigation.zoom(2);\n\tthis.globe.refresh();\n}\n\n/**\n * Zoom to the given extent\n */\nGlobWebMapEngine.prototype.zoomToExtent = function(extent) {\n\tvar lon = (extent[0] + extent[2]) * 0.5;\n\tvar lat = (extent[1] + extent[3]) * 0.5;\n\n\tvar lonInRad1 = extent[0] * Math.PI / 180;\n\tvar lonInRad2 = extent[2] * Math.PI / 180;\n\tvar latInRad = lat * Math.PI / 180;\n\n\tvar R = 6371000;\n\tvar x = (lonInRad2 - lonInRad1) * Math.cos(latInRad);\n\tvar d = x * R;\n\n\td = d / Math.cos(22.5 * Math.PI / 180);\n\td = Math.min(d, R * 2);\n\n\tvar geoPos = [lon, lat];\n\tthis.navigation.zoomTo(geoPos, d, Configuration.get('map.globweb.zoomDuration', 500));\n}\n\n\n/**\n * Remove all features from a layer\n */\nGlobWebMapEngine.prototype.removeAllFeatures = function(layer) {\n\tlayer.removeAllFeatures();\n}\n\n/**\n * Add a feature on the map\n */\nGlobWebMapEngine.prototype.addFeature = function(layer, feature) {\n\tvar isCollection = feature.type == 'FeatureCollection';\n\tif (isCollection) {\n\t\tlayer.addFeatureCollection(feature);\n\t} else {\n\t\tlayer.addFeature(feature);\n\t}\n}\n\n/**\n * Modify the product style\n */\nGlobWebMapEngine.prototype.modifyFeatureStyle = function(layer, feature, style) {\n\tlayer.modifyFeatureStyle(feature, layer.styleMap[style]);\n\tthis.globe.refresh();\n}\n\n/**\n * Block the navigation\n */\nGlobWebMapEngine.prototype.blockNavigation = function(flag) {\n\tif (flag) {\n\t\tthis.navigation.stop();\n\t} else {\n\t\tthis.navigation.start();\n\t}\n}\n\n/**\n * Update a feature\n */\nGlobWebMapEngine.prototype.updateFeature = function(layer, feature) {\n\tlayer.removeFeature(feature);\n\tlayer.addFeature(feature);\n}\n\n/**\n * Remove a feature\n */\nGlobWebMapEngine.prototype.removeFeature = function(layer, feature) {\n\tlayer.removeFeature(feature);\n}\n\n/**\n *\tUpdates style for the given feature according to conditional styling from configuration\n *\tif applicable, otherwise return the initial style\n */\nGlobWebMapEngine.prototype.applyConditionalStyling = function(layer, feature, style) {\n\tvar currentStyle = style;\n\tvar engineStyles = layer.styleMap;\n\tfor ( var x in engineStyles ) {\n\t\tvar engineStyle = engineStyles[x];\n\t\tif ( engineStyle.isApplicable && engineStyle.isApplicable(feature, style) ) {\n\t\t\tcurrentStyle = x;\n\t\t}\n\t}\n\treturn currentStyle;\n}\n\n/**\n *  Destroy the map engine\n */\nGlobWebMapEngine.prototype.destroy = function() {\n\tthis.globe.dispose();\n\n\tthis.parentElement.removeChild(this.canvas);\n\tthis.parentElement.removeChild(this.attributions);\n\tif (this.stats) {\n\t\tthis.parentElement.removeChild(this.stats);\n\t}\n\tthis.$loading.remove();\n\n\t// Free the object\n\tthis.globe = null;\n\tthis.parentElement = null;\n\tthis.canvas = null;\n\tthis.attributions = null;\n\tthis.navigation = null;\n}\n\nmodule.exports = GlobWebMapEngine;","var Map = require('map/map');\r\n\r\n// Base object for handler\r\n// Take as input the implementation\r\nvar Handler = function(impl) {\r\n\r\n\t// Private variables\r\n\tvar _previousHandler = null;\r\n\r\n\t/**\r\n\t * Public interface\r\n\t */\r\n\tthis.start = function(options) {\r\n\t\t_previousHandler = Map.handler;\r\n\t\tif (_previousHandler) {\r\n\t\t\t_previousHandler.stop();\r\n\t\t}\r\n\t\tMap.handler = this;\r\n\r\n\t\timpl.start(options);\r\n\t};\r\n\r\n\tthis.stop = function() {\r\n\t\timpl.stop();\r\n\r\n\t\tMap.handler = null;\r\n\t\tif (_previousHandler) {\r\n\t\t\t_previousHandler.start();\r\n\t\t\t_previousHandler = null;\r\n\t\t}\r\n\t};\r\n\r\n\t// Copy other methods\r\n\tfor (var x in impl) {\r\n\t\tif (impl[x] instanceof Function && x != 'start' && x != 'stop') {\r\n\t\t\tthis[x] = impl[x];\r\n\t\t}\r\n\t}\r\n};\r\n\r\nmodule.exports = Handler;","/**\r\n * LayerImport module\r\n * The function to define the LayerImport module\r\n */\r\n\r\nvar Map = require('map/map');\r\n\r\n/**\r\n * A function to cancel default drag event.\r\n * Needed when setup a droppable area.\r\n */\r\nvar cancelDefaultDrag = function(evt) {\r\n\tif (evt.preventDefault) {\r\n\t\tevt.preventDefault();\r\n\t}\r\n\treturn false;\r\n};\r\n\r\nvar handleDrop = function(event, onload) {\r\n\tevent.stopPropagation(); // Stops some browsers from redirecting.\r\n\tevent.preventDefault();\r\n\r\n\tvar files = event.dataTransfer.files;\r\n\tfor (var i = 0; i < files.length; i++) {\r\n\t\t// Read the File objects in this FileList.\r\n\t\tvar reader = new FileReader();\r\n\t\tvar file = files[i];\r\n\t\tvar ext = file.name.substr(file.name.indexOf('.') + 1);\r\n\r\n\t\t// If we use onloadend, we need to check the readyState.\r\n\t\treader.onloadend = function(evt) {\r\n\t\t\tif (evt.target.readyState == FileReader.DONE) { // DONE == 2\r\n\r\n\t\t\t\t// Fill the layer description\r\n\t\t\t\tvar layerDesc = {\r\n\t\t\t\t\tname: \"Imported File : \" + file.name,\r\n\t\t\t\t\ttype: ext,\r\n\t\t\t\t\tvisible: true,\r\n\t\t\t\t\tstyle: \"imported\",\r\n\t\t\t\t\tdata: evt.target.result\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (!onload) {\r\n\t\t\t\t\t//Add it to the map\r\n\t\t\t\t\tMap.addLayer(layerDesc);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tonload(layerDesc, file);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\treader.readAsText(file);\r\n\t}\r\n};\r\n\r\n\r\n\r\n/**\r\n * Public interface\r\n */\r\nmodule.exports = {\r\n\r\n\t/**\r\n\t * Add a drop area for import layer\r\n\t *\r\n\t * @param element  The HTML element for the drop area\r\n\t * @param onload\tA callback called when the layer has been successfully loaded, if no callback the layer is added to the map\r\n\t */\r\n\taddDropArea: function(element, onload) {\r\n\r\n\t\t// Tells the browser that we *can* drop on this target\r\n\t\telement.addEventListener('dragover', cancelDefaultDrag);\r\n\t\telement.addEventListener('dragenter', cancelDefaultDrag);\r\n\r\n\t\t// Activate handle drop\r\n\t\telement.addEventListener(\"drop\", function(event) {\r\n\t\t\thandleDrop(event, onload);\r\n\t\t});\r\n\t},\r\n\r\n\tisSupported: function() {\r\n\t\treturn window.FileReader != undefined;\r\n\t},\r\n\r\n};","/**\r\n * Map module\r\n * The function to define the map module\r\n */\r\n\r\n\r\nvar Configuration = require('configuration');\r\nvar OpenLayersMapEngine = require('map/openlayers');\r\nvar GlobWebMapEngine = require('map/globweb');\r\nvar UserPrefs = require('userPrefs');\r\nvar BrowsesLayer = require('map/browsesLayer');\r\nvar MapUtils = require('map/utils');\r\nvar DegreeConvertor = require('map/degreeConvertor');\r\n\r\n\r\n/**\r\n * Inner class\r\n */\r\n\r\n/**\r\n * A basic static layer only for visualisation\r\n */\r\nvar Layer = function(params, engineLayer) {\r\n\r\n\t// The parameters of layer (name, visibility, type...)\r\n\tthis.params = params;\r\n\t// The engine layer\r\n\tthis.engineLayer = engineLayer;\r\n\r\n\tthis.setVisible = function(vis) {\r\n\t\tthis.params.visible = vis;\r\n\r\n\t\tif ( this.params.type != \"Feature\" ) {\r\n\t\t\t// Store only raster layers into user preferences for now\r\n\t\t\tvar visibleLayers = JSON.parse(UserPrefs.get(\"Visible layers\") || \"[]\");\r\n\t\t\tif ( vis ) {\r\n\t\t\t\tvisibleLayers.push(this.params.name);\r\n\t\t\t} else {\r\n\t\t\t\tvar idx = visibleLayers.indexOf(this.params.name);\r\n\t\t\t\tif ( idx != -1 ) {\r\n\t\t\t\t\tvisibleLayers.splice(idx, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tUserPrefs.save(\"Visible layers\", JSON.stringify(visibleLayers));\r\n\t\t}\r\n\r\n\t\tmapEngine.setLayerVisible(this.engineLayer, vis);\r\n\t\tself.trigger(\"visibility:changed\", this);\r\n\t};\r\n\tthis.changeEngine = function(mapEngine) {\r\n\t\tthis.engineLayer = mapEngine.addLayer(this.params);\r\n\t};\r\n};\r\n\r\n/**\r\n *\tTesselate great circle helper function\r\n *\tNGEO-808: Fixes the rhumb line(constant azimuth) feature geometry to follow the great circles one\r\n *\t@see http://it.mathworks.com/help/map/great-circles-rhumb-lines-and-small-circles.html\r\n *\r\n *\tAlso adds _origGeometry attribute on feature to be used on export\r\n */\r\nvar tesselateGreatCircle = function(params, feature) {\r\n\tvar needToBeTesselated = (params.greatCircle && !feature._origGeometry);\r\n\tif (needToBeTesselated) {\r\n\t\t// NGEO-1778: Store original geometry on feature, used on KML/GeoJSON/other export\r\n\t\tfeature._origGeometry = {\r\n\t\t\tcoordinates: $.extend(true, [], feature.geometry.coordinates),\r\n\t\t\ttype: feature.geometry.type\r\n\t\t};\r\n\t\tMapUtils.tesselateGreatCircle(feature);\r\n\t}\r\n}\r\n\r\n/**\r\n * A feature layer to add dynamically new feature\r\n */\r\nvar FeatureLayer = function(params, engineLayer) {\r\n\tLayer.prototype.constructor.call(this, params, engineLayer);\r\n\r\n\t// The features\r\n\tthis.features = [];\r\n\r\n\tthis.clear = function() {\r\n\t\tthis.features = [];\r\n\t\tmapEngine.removeAllFeatures(this.engineLayer);\r\n\t};\r\n\tthis.addFeatures = function(features) {\r\n\t\tfor (var i = 0; i < features.length; i++) {\r\n\t\t\tthis.addFeature(features[i]);\r\n\t\t}\r\n\t};\r\n\tthis.addFeature = function(feature) {\r\n\t\tif (feature.geometry) {\r\n\t\t\ttesselateGreatCircle(params, feature);\r\n\t\t\tmapEngine.addFeature(this.engineLayer, feature);\r\n\t\t\tthis.modifyFeaturesStyle([feature], \"default\");\r\n\t\t\tthis.features.push(feature);\r\n\t\t}\r\n\t};\r\n\tthis.removeFeatures = function(features) {\r\n\t\tfor (var i = 0; i < features.length; i++) {\r\n\t\t\tmapEngine.removeFeature(this.engineLayer, features[i]);\r\n\t\t\tthis.features.splice(this.features.indexOf(features[i]), 1);\r\n\t\t}\r\n\t};\r\n\r\n\tthis.modifyFeaturesStyle = function(features, style) {\r\n\t\tfor (var i = 0; i < features.length; i++) {\r\n\t\t\tvar feature = features[i];\r\n\t\t\tstyle = mapEngine.applyConditionalStyling(this.engineLayer, feature, style);\r\n\t\t\tfeature.renderHint = style;\r\n\t\t\tmapEngine.modifyFeatureStyle(this.engineLayer, feature, feature.renderHint);\r\n\t\t}\r\n\t};\r\n\tthis.updateFeature = function(feature, customFixDateLine) {\r\n\t\ttesselateGreatCircle(params, feature);\r\n\t\tmapEngine.updateFeature(this.engineLayer, feature, customFixDateLine);\r\n\t};\r\n\tthis.changeEngine = function(mapEngine) {\r\n\t\tthis.engineLayer = mapEngine.addLayer(this.params);\r\n\t\t// Re-add the features to the engine\r\n\t\tfor (var i = 0; i < this.features.length; i++) {\r\n\t\t\tvar f = this.features[i];\r\n\t\t\tf.geometry = _.omit(f.geometry, '_bucket', '_tileIndices');\r\n\t\t\tmapEngine.addFeature(this.engineLayer, f);\r\n\t\t\tif (f.renderHint) {\r\n\t\t\t\tmapEngine.modifyFeatureStyle(this.engineLayer, f, f.renderHint);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n};\r\n\r\n\r\n/**\r\n * Private attributes\r\n */\r\n\r\n// Reference to the map singleton\r\nvar self = null;\r\n// The different engines used by the map\r\nvar engines = {\r\n\t'2d': OpenLayersMapEngine,\r\n\t'3d': GlobWebMapEngine,\r\n};\r\n// The current map engine\r\nvar mapEngine = null;\r\n// The map DOM element\r\nvar element = null;\r\n// The current background layer\r\nvar backgroundLayer = null;\r\n// Max extent of the map\r\nvar maxExtent = [-180, -85, 180, 85];\r\n// To know if map is in geographic or not\r\nvar isGeo = false;\r\n\r\n/**\r\n * Build the layer from its parameter\r\n */\r\nvar buildLayer = function(params) {\r\n\tif (params.type == \"Browses\") {\r\n\t\treturn new BrowsesLayer(params, mapEngine);\r\n\t} else if (params.type == \"Feature\") {\r\n\t\treturn new FeatureLayer(params, mapEngine.addLayer(params));\r\n\t} else {\r\n\t\tvar engineLayer = mapEngine.addLayer(params);\r\n\t\tif (engineLayer) {\r\n\t\t\treturn new Layer(params, engineLayer);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * Called when mouse is moved on map : update coordinates viewer\r\n */\r\nvar onMouseMove = function(event) {\r\n\tvar point = self.getLonLatFromEvent(event);\r\n\r\n\tif (point) {\r\n\t\tvar lon = DegreeConvertor.toDMS(point[0], true);\r\n\t\tvar lat = DegreeConvertor.toDMS(point[1], false);\r\n\r\n\t\t// Append zero before decimals < 10 to have the same width \r\n\t\tlon = lon.replace(/\\b(\\d{1})\\b/g, '0$1');\r\n\t\tlat = lat.replace(/\\b(\\d{1})\\b/g, '0$1');\r\n\r\n\t\t$('#coordinatesViewer')\r\n\t\t\t.html(lat + \" \" + lon);\r\n\t}\r\n};\r\n\r\n/**\r\n * Configure the map engine : set background layer, adjust style, connect events, etc...\r\n */\r\nvar configureMapEngine = function(mapConf) {\r\n\r\n\tmapEngine.setBackgroundLayer(backgroundLayer);\r\n\r\n\t// Add the style in conf to the engines\r\n\tfor (var x in mapConf.styles) {\r\n\t\tif (mapConf.styles.hasOwnProperty(x)) {\r\n\t\t\tmapEngine.addStyle(x, mapConf.styles[x]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Change the layer engine\r\n\tfor (var i = 0; i < self.layers.length; i++) {\r\n\t\tself.layers[i].changeEngine(mapEngine);\r\n\t}\r\n\r\n\t// Zoom to max extent\r\n\tmapEngine.zoomToExtent(maxExtent);\r\n\r\n\t// Subscribe to event\r\n\tmapEngine.subscribe(\"navigationModified\", function() {\r\n\t\tself.trigger(\"extent:change\", self);\r\n\t});\r\n\r\n\t// Update coordinates viewer context on mouse move\r\n\tmapEngine.subscribe(\"mousemove\", onMouseMove);\r\n};\r\n\r\n/**\r\n * Check if layers are compatible\r\n */\r\nvar isLayerCompatible = function(layer) {\r\n\tswitch (layer.type) {\r\n\t\tcase \"Bing\":\r\n\t\tcase \"OSM\":\r\n\t\t\treturn !isGeo;\r\n\t\tcase \"WMTS\":\r\n\t\t\treturn Configuration.data.map.projection == layer.projection;\r\n\t\tcase \"WMS\":\r\n\t\t\treturn layer.projection ? Configuration.data.map.projection == layer.projection : true;\r\n\t\tcase \"GeoJSON\":\r\n\t\tcase \"KML\":\r\n\t\tcase \"GeoRSS\":\r\n\t\tcase \"WFS\":\r\n\t\t\treturn true;\r\n\t\tdefault:\r\n\t\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Public interface\r\n */\r\nmodule.exports = {\r\n\r\n\t/**\r\n\t * The handler used for interaction with the map : selection, polygon drawing, etc..\r\n\t */\r\n\thandler: null,\r\n\r\n\t/**\r\n\t * The background layers that can be used on the map.\r\n\t * Loaded from configuration, this array only stores the 'compatible' background layers\r\n\t */\r\n\tbackgroundLayers: [],\r\n\r\n\t/**\r\n\t * The layers applied on the map.\r\n\t * Loaded from configuration, this array only stores the 'compatible' layers\r\n\t */\r\n\tlayers: [],\r\n\r\n\t/**\r\n\t * Initialize module\r\n\t */\r\n\tinitialize: function(eltId) {\r\n\r\n\t\t// Keep the this\r\n\t\tself = this;\r\n\r\n\t\t_.extend(self, Backbone.Events);\r\n\r\n\t\telement = document.getElementById(eltId);\r\n\r\n\t\tvar preferedMapEngine = UserPrefs.get(\"Map mode\") ? UserPrefs.get(\"Map mode\") : '2d';\r\n\t\tmapEngine = new engines[preferedMapEngine](element);\r\n\r\n\t\t// Check layers from configuration\r\n\t\tisGeo = Configuration.data.map.projection == \"EPSG:4326\";\r\n\r\n\t\t// Build the background layers from the configuration\r\n\t\tvar confBackgroundLayers = Configuration.data.map.backgroundLayers;\r\n\t\tfor (var i = 0; i < confBackgroundLayers.length; i++) {\r\n\t\t\tif (isLayerCompatible(confBackgroundLayers[i])) {\r\n\t\t\t\tself.backgroundLayers.push(confBackgroundLayers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar visibleLayers = JSON.parse(UserPrefs.get(\"Visible layers\") || \"[]\");\r\n\t\t// Build the addtionnal layers from the configuration\r\n\t\tvar confLayers = Configuration.data.map.layers;\r\n\t\tfor (var i = 0; i < confLayers.length; i++) {\r\n\t\t\tvar layerConf = confLayers[i];\r\n\t\t\tif (isLayerCompatible(layerConf)) {\r\n\r\n\t\t\t\t// Update visibilty according to user preferences\r\n\t\t\t\tif ( visibleLayers.indexOf(layerConf.name) != -1 ) {\r\n\t\t\t\t\tlayerConf.visible = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tself.layers.push(new Layer(layerConf, null));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set the background layer from the preferences if it exists,\r\n\t\t// otherwise set it to be the first one in the list of background layers\r\n\t\tvar preferedBackgroundId = UserPrefs.get(\"Background\");\r\n\t\tbackgroundLayer = _.findWhere(self.backgroundLayers, {id: preferedBackgroundId});\r\n\t\tif ( !backgroundLayer ) {\r\n\t\t\tbackgroundLayer = self.backgroundLayers[0];\r\n\t\t}\r\n\r\n\t\tconfigureMapEngine(Configuration.data.map);\r\n\t},\r\n\r\n\t/**\r\n\t * Modify the background layer on the map and save it to the preferences.\r\n\t *\r\n\t * @param layer The layer to use as new background\r\n\t */\r\n\tsetBackgroundLayer: function(layer) {\r\n\t\t// Store background layer\r\n\t\tbackgroundLayer = layer;\r\n\t\t// Set the active background\r\n\t\tvar engineLayer = mapEngine.setBackgroundLayer(layer);\r\n\t\tUserPrefs.save('Background', layer.id);\r\n\t\tthis.trigger('backgroundLayerSelected', layer);\r\n\t\treturn engineLayer;\r\n\t},\r\n\r\n\t/**\r\n\t * Get the selected background layer\r\n\t */\r\n\tgetBackgroundLayer: function() {\r\n\t\treturn backgroundLayer;\r\n\t},\r\n\r\n\t/**\r\n\t * Dynamically add a layer to the map\r\n\t *\r\n\t * @param layerDesc\tThe layer description\r\n\t */\r\n\taddLayer: function(params) {\r\n\t\tvar layer;\r\n\t\tif (!params.isBackground) {\r\n\t\t\tlayer = buildLayer(params);\r\n\t\t\tself.layers.push(layer);\r\n\t\t\tself.trigger('layerAdded', layer);\r\n\t\t\t//console.log(layer.engineLayer.id + \" added\");\r\n\t\t} else {\r\n\t\t\tif (params.visible)\r\n\t\t\t\tlayer = this.setBackgroundLayer(params);\r\n\t\t\tself.backgroundLayers.push(params);\r\n\t\t\tself.trigger('backgroundLayerAdded', params);\r\n\t\t}\r\n\r\n\t\treturn layer;\r\n\t},\r\n\r\n\t/**\r\n\t * Dynamically remove a layer from the map\r\n\t *\r\n\t * @param layer The layer (as returned by addLayer)\r\n\t */\r\n\tremoveLayer: function(layer) {\r\n\t\tif (!layer.params.isBackground) {\r\n\t\t\t//console.log(\"Try to remove\" + layer.engineLayer.id);\r\n\t\t\t//var layer = _.findWhere(self.layers, {params: layerDesc});\r\n\t\t\tvar index = self.layers.indexOf(layer);\r\n\t\t\tif (index >= 0) {\r\n\t\t\t\tvar layer = self.layers[index];\r\n\t\t\t\tif (layer.clear) {\r\n\t\t\t\t\tlayer.clear();\r\n\t\t\t\t}\r\n\t\t\t\tif (layer.engineLayer) {\r\n\t\t\t\t\tmapEngine.removeLayer(layer.engineLayer);\r\n\t\t\t\t}\r\n\t\t\t\tvar index = self.layers.indexOf(layer);\r\n\t\t\t\tself.layers.splice(index, 1);\r\n\t\t\t\tself.trigger('layerRemoved', layer);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar index = self.backgroundLayers.indexOf(layer.params);\r\n\t\t\t// var index = self.backgroundLayers.indexOf(layerDesc);\r\n\t\t\tvar layer = self.backgroundLayers[index];\r\n\t\t\tif (index >= 0) {\r\n\t\t\t\tself.backgroundLayers.splice(index, 1);\r\n\r\n\t\t\t\t// Check first one by default\r\n\t\t\t\tif (backgroundLayer == layer.params) {\r\n\t\t\t\t\tself.setBackgroundLayer(self.backgroundLayers[0]);\r\n\t\t\t\t}\r\n\t\t\t\tself.trigger('backgroundLayerRemoved', layer);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tzoomIn: function() {\r\n\t\tmapEngine.zoomIn();\r\n\t},\r\n\r\n\tzoomOut: function() {\r\n\t\tmapEngine.zoomOut();\r\n\t},\r\n\r\n\tzoomToMaxExtent: function() {\r\n\t\tmapEngine.zoomToExtent(maxExtent);\r\n\t},\r\n\r\n\tzoomToFeature: function(feature) {\r\n\t\t// Zoom on the product in the carto\r\n\t\tif (!feature.bbox) {\r\n\t\t\tMapUtils.computeExtent(feature);\r\n\t\t}\r\n\t\tvar extent = feature.bbox;\r\n\t\tvar width = extent[2] - extent[0];\r\n\t\tvar height = extent[3] - extent[1];\r\n\t\tvar offsetExtent = [extent[0] - 2 * width, extent[1] - 2 * height, extent[2] + 2 * width, extent[3] + 2 * height];\r\n\t\tmapEngine.zoomToExtent(offsetExtent);\r\n\t},\r\n\r\n\tzoomTo: function(extent) {\r\n\t\tmapEngine.zoomToExtent(extent);\r\n\t},\r\n\r\n\t/**\r\n\t * Get current viewport extent\r\n\t * @return an array of 4 number : [west,south,east,north]\r\n\t */\r\n\tgetViewportExtent: function() {\r\n\t\tvar extent = mapEngine.getViewportExtent();\r\n\t\textent[0] = MapUtils.normalizeLon(extent[0]);\r\n\t\textent[1] = Math.max(-90.0, extent[1]);\r\n\t\textent[2] = MapUtils.normalizeLon(extent[2]);\r\n\t\textent[3] = Math.min(90.0, extent[3]);\r\n\t\treturn extent;\r\n\t},\r\n\r\n\t/**\r\n\t * Get the pixel position (in the element) from a lonlat\r\n\t */\r\n\tgetPixelFromLonLat: function(lon, lat) {\r\n\t\treturn mapEngine.getPixelFromLonLat(lon, lat);\r\n\t},\r\n\r\n\t/**\r\n\t * Get the lonlat from a pixel position (in the element) \r\n\t */\r\n\tgetLonLatFromPixel: function(x, y) {\r\n\t\treturn mapEngine.getLonLatFromPixel(x, y);\r\n\t},\r\n\r\n\t/**\r\n\t * Get the lonlat from an event\r\n\t */\r\n\tgetLonLatFromEvent: function(event) {\r\n\t\tvar rect = element.getBoundingClientRect();\r\n\t\tvar clientX = event.pageX - rect.left;\r\n\t\tvar clientY = event.pageY - rect.top;\r\n\t\treturn mapEngine.getLonLatFromPixel(clientX, clientY);\r\n\t},\r\n\r\n\t/**\r\n\t * Switch the map engine\r\n\t */\r\n\tswitchMapEngine: function(id) {\r\n\t\tif (!engines[id]) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar previousHandler = null;\r\n\r\n\t\tif (mapEngine) {\r\n\t\t\t// Stop current handler because it depends on the map engine\r\n\t\t\tif (this.handler) {\r\n\t\t\t\tpreviousHandler = this.handler;\r\n\t\t\t\tthis.handler.stop();\r\n\t\t\t}\r\n\r\n\t\t\t// Unsubscribe old on mouse move handler\r\n\t\t\tmapEngine.unsubscribe(\"mousemove\", onMouseMove);\r\n\r\n\t\t\t// Retrieve the current viewport extent\r\n\t\t\tvar extent = mapEngine.getViewportExtent();\r\n\r\n\t\t\t// Destroy the old map engine\r\n\t\t\tmapEngine.destroy();\r\n\t\t\tmapEngine = null;\r\n\r\n\t\t}\r\n\r\n\t\t// Callback called by the map engine when the map engine is initialized\r\n\t\tvar initCallback = function(map) {\r\n\t\t\t// Configure the map engine\r\n\t\t\tconfigureMapEngine(Configuration.data.map);\r\n\r\n\t\t\t// Zoom to previous extent\r\n\t\t\tif (extent)\r\n\t\t\t\tmap.zoomToExtent(extent);\r\n\r\n\t\t\tif (previousHandler)\r\n\t\t\t\tpreviousHandler.start();\r\n\r\n\t\t};\r\n\r\n\t\t// Create the new engine and catch any error\r\n\t\ttry {\r\n\t\t\tmapEngine = new engines[id](element);\r\n\t\t} catch (err) {\r\n\t\t\tmapEngine = null;\r\n\t\t}\r\n\r\n\t\tUserPrefs.save(\"Map mode\", id);\r\n\r\n\t\tif (mapEngine) {\r\n\t\t\tmapEngine.subscribe(\"init\", initCallback);\r\n\t\t}\r\n\r\n\t\treturn mapEngine != null;\r\n\t},\r\n\r\n\t/**\r\n\t * Method to call when the map viewport is resized\r\n\t */\r\n\tupdateViewportSize: function() {\r\n\t\tif (mapEngine)\r\n\t\t\tmapEngine.updateSize();\r\n\t},\r\n\r\n\tgetMapEngine: function() {\r\n\t\treturn mapEngine;\r\n\t}\r\n};","/**\n * OpenLayers map engine\n */\n\nvar Configuration = require('configuration');\nvar MapUtils = require('map/utils');\n//require('OpenLayers');\n\nvar _projection = Configuration.get('map.projection', \"EPSG:4326\");\n\n/**\n * Setup the resolution to be used by a WMTS layer using the grid for the given projection\n */\nvar _buildWMTSResolution = function() {\n\tif (_projection == \"EPSG:4326\") {\n\t\tvar resolutions = [180.0 / 256];\n\t\tfor (var i = 0; i < 15; i++) {\n\t\t\tresolutions.push(resolutions[resolutions.length - 1] * 0.5);\n\t\t}\n\t\treturn resolutions;\n\t} else {\n\t\t//console.log(\"WMTS : no resolution exists for this projection  : \" + _projection);\n\t\treturn null;\n\t}\n};\n\n/**\n * Setup WMTS\n */\nvar _setupWMTS = function(config) {\n\tconfig.serverResolutions = _buildWMTSResolution();\n\tif (_projection == \"EPSG:4326\") {\n\t\tconfig.tileFullExtent = new OpenLayers.Bounds(-180, -90, 180, 90);\n\t\tconfig.tileOrigin = new OpenLayers.LonLat(-180, 90);\n\t} else if ( _projection == \"EPSG:3857\" ) {\n\t\tconfig.tileFullExtent = new OpenLayers.Bounds(-20037508.34278925, -20037508.34278925, 20037508.34278925, 20037508.34278925);\n\t\tconfig.tileOrigin = new OpenLayers.LonLat( -20037508.34278925, 20037508.34278925 );\n\t} /* else {\n\t\tconsole.log(\"WMTS : no setup exists for this projection  : \" + _projection);\n\t} */\n}\n\n\n/**\n * Constructor\n * parentElement : the parent element div for the map\n */\nOpenLayersMapEngine = function(element) {\n\t// Store element\n\tthis.element = element;\n\n\t// Retreive restricted extent from configuration\n\tvar resExtent = Configuration.get('map.openlayers.restrictedExtent', [-180, -90, 180, 90]);\n\n\t// Get projection\n\tvar mapProjection = new OpenLayers.Projection(Configuration.get('map.projection', \"EPSG:4326\"));\n\tvar displayProjection = new OpenLayers.Projection(\"EPSG:4326\");\n\n\t// Transform restricted extent to the map projection\n\tvar restrictedExtent = new OpenLayers.Bounds(resExtent);\n\trestrictedExtent.transform(displayProjection, mapProjection);\n\n\t// Setup the best resolutions to use with the following constraint :\n\t// fit the WMTS layers and depends on the viewport size\n\tvar resolutions = this.computeResolutions(restrictedExtent);\n\n\t// Create the map\n\tthis._map = new OpenLayers.Map(this.element, {\n\t\tcontrols: [\n\t\t\tnew OpenLayers.Control.Navigation({\n\t\t\t\tzoomWheelEnabled: true,\n\t\t\t\tdefaultDblClick: function(event) { return; }\n\t\t\t}),\n\t\t\tnew OpenLayers.Control.Attribution()\n\t\t],\n\t\tprojection: mapProjection,\n\t\tdisplayProjection: displayProjection,\n\t\trestrictedExtent: restrictedExtent,\n\t\ttheme: null,\n\t\t\t// NEVER USE fractionnal zoom right now, break the WMTS display as overlay\n\t\t\t// fractionalZoom: true,\n\t\tautoUpdateSize: false,\n\t\tresolutions: resolutions,\n\t\tfallThrough: true\n\t});\n\n\t// Create the converter for GeoJSON format\n\tthis._geoJsonFormat = new OpenLayers.Format.GeoJSON({\n\t\texternalProjection: this._map.displayProjection,\n\t\tinternalProjection: this._map.projection\n\t});\n\n\tthis.styles = {};\n};\n\n\n/**\n * Compute the resolutions array from the given extent and the element size\n */\nOpenLayersMapEngine.prototype.computeResolutions = function(restrictedExtent) {\n\t// Setup the resolution, the same as used for WMTS\n\tvar resolutions = _buildWMTSResolution();\n\n\tif (resolutions) {\n\n\t\t// Compute the max resolution\n\t\tvar maxWRes = (restrictedExtent.right - restrictedExtent.left) / this.element.offsetWidth;\n\t\tvar maxHRes = (restrictedExtent.top - restrictedExtent.bottom) / this.element.offsetHeight;\n\t\tvar maxResolution = Math.min(maxWRes, maxHRes)\n\n\t\t// Modify the resolutions array to be strictly inferior to maxResolution\n\t\twhile (resolutions[0] > maxResolution) {\n\t\t\tresolutions.shift();\n\t\t}\n\n\t}\n\n\treturn resolutions;\n};\n\n/**\n *\tCreate conditional OpenLayers style from configuration\n *\t@see For more details see NGEO-2222\n */\nOpenLayersMapEngine.prototype.createConditionalStyles = function(baseStyle, condStyle) {\n\tvar styleHints = ['default', 'select', 'highlight', 'highlight-select'];\n\t_.each(styleHints, function(styleHint) {\n\t\tif ( condStyle[styleHint] ) {\n\t\t\tvar s = new OpenLayers.Style(condStyle[styleHint]);\n\t\t\ts.isApplicable = function(feature, style) {\n\t\t\t\treturn style == styleHint && Configuration.getFromPath(feature, condStyle.attribute) == condStyle.value;\n\t\t\t}\n\t\t\tbaseStyle.styles[ condStyle.attribute+\"-\"+condStyle.value+\"-\"+styleHint ] = s;\n\t\t}\n\t});\n};\n\n/**\n * Add a style\n */\nOpenLayersMapEngine.prototype.addStyle = function(name, style) {\n\tthis.styles[name] = new OpenLayers.StyleMap( style );\n\tif ( style.conditionals ) {\n\t\tvar self = this;\n\t\tfor ( var i=0; i<style.conditionals.length; i++ ) {\n\t\t\tself.createConditionalStyles(self.styles[name], style.conditionals[i]);\n\t\t}\n\t}\n};\n\n/**\n * Set the background layer\n */\nOpenLayersMapEngine.prototype.setBackgroundLayer = function(layer) {\n\n\tvar olLayer;\n\tswitch (layer.type.toUpperCase()) {\n\t\tcase \"OSM\":\n\t\t\tolLayer = new OpenLayers.Layer.OSM(layer.name, layer.baseUrl + \"/${z}/${x}/${y}.png\");\n\t\t\tbreak;\n\t\tcase \"WMS\":\n\t\t\tolLayer = new OpenLayers.Layer.WMS(layer.name, layer.baseUrl, layer.params);\n\t\t\tbreak;\n\t\tcase \"BING\":\n\t\t\tolLayer = new OpenLayers.Layer.Bing({\n\t\t\t\tname: layer.name,\n\t\t\t\tkey: layer.key,\n\t\t\t\ttype: layer.imageSet\n\t\t\t});\n\t\t\tbreak;\n\t\tcase \"WMTS\":\n\t\t\tvar config = {\n\t\t\t\tname: layer.name,\n\t\t\t\turl: layer.baseUrl,\n\t\t\t\tlayer: layer.params.layer,\n\t\t\t\tmatrixSet: layer.params.matrixSet,\n\t\t\t\tmatrixIds: layer.params.matrixIds,\n\t\t\t\tformat: layer.params.format,\n\t\t\t\tstyle: layer.params.style,\n\t\t\t\tisBaseLayer: true,\n\t\t\t\tprojection: layer.projection\n\t\t\t};\n\n\t\t\t_setupWMTS(config);\n\n\t\t\t// Manage bbox(not really useful since background layer is generally covers a whole world, but just in case..)\n\t\t\tif (layer.bbox) {\n\t\t\t\tconfig.maxExtent = new OpenLayers.Bounds(layer.bbox);\n\t\t\t}\n\n\t\t\tolLayer = new OpenLayers.Layer.WMTS(config);\n\n\t\t\tbreak;\n\t}\n\n\tif (olLayer) {\n\t\t// Set common options\n\t\tolLayer.attribution = layer.attribution;\n\t\tolLayer.wrapDateLine = true;\n\t\tolLayer.transitionEffect = Configuration.get('map.openlayers.transitionEffect', null);\n\n\t\t// Finally add to map\n\t\tthis._map.addLayer(olLayer);\n\t\tthis._map.setBaseLayer(olLayer);\n\n\t\t// Fix wrong TILEMATRIX identifier for (at least) WMTS layer when it has been set on initialization\n\t\t// FIXME: Check if there is no better way to handle it..\n\t\tif ( olLayer.updateMatrixProperties ) {\n\t\t\tolLayer.updateMatrixProperties();\n\t\t}\n\t}\n\treturn olLayer;\n}\n\n/**\n * Set layer visibility\n */\nOpenLayersMapEngine.prototype.setLayerVisible = function(olLayer, vis) {\n\tolLayer.setVisibility(vis);\n}\n\n/**\n * Set layer index\n */\nOpenLayersMapEngine.prototype.setLayerIndex = function(olLayer, index) {\n\tthis._map.setLayerIndex(olLayer, index);\n}\n\n/**\n * Add a layer\n */\nOpenLayersMapEngine.prototype.addLayer = function(layer) {\n\n\tvar olLayer;\n\tswitch (layer.type.toUpperCase()) {\n\t\tcase \"WMS\":\n\t\t\tvar maxExtent;\n\t\t\tif (layer.bbox) {\n\t\t\t\tmaxExtent = new OpenLayers.Bounds(layer.bbox[0], layer.bbox[1], layer.bbox[2], layer.bbox[3]);\n\t\t\t\tmaxExtent.transform(this._map.displayProjection, this._map.projection);\n\t\t\t}\n\t\t\tolLayer = new OpenLayers.Layer.WMS(layer.name,\n\t\t\t\tlayer.baseUrl,\n\t\t\t\tlayer.params, {\n\t\t\t\t\tmaxExtent: maxExtent,\n\t\t\t\t\tisBaseLayer: false,\n\t\t\t\t\topacity: layer.hasOwnProperty('opacity') ? layer.opacity : 1.0\n\t\t\t\t});\n\t\t\tbreak;\n\t\tcase \"WMTS\":\n\t\t\tvar config = {\n\t\t\t\tname: layer.name,\n\t\t\t\turl: layer.baseUrl,\n\t\t\t\tlayer: layer.params.layer,\n\t\t\t\tmatrixSet: layer.params.matrixSet,\n\t\t\t\tmatrixIds: layer.params.matrixIds,\n\t\t\t\tformat: layer.params.format,\n\t\t\t\tstyle: layer.params.style,\n\t\t\t\tisBaseLayer: false,\n\t\t\t\tprojection: layer.projection,\n\t\t\t\topacity: layer.hasOwnProperty('opacity') ? layer.opacity : 1.0,\n\t\t\t\ttransitionEffect: Configuration.get('map.openlayers.transitionEffect', null)\n\t\t\t};\n\n\t\t\t_setupWMTS(config);\n\n\t\t\t// Manage time\n\t\t\tif (layer.params.time) {\n\t\t\t\tconfig.dimensions = ['TIME'];\n\t\t\t\tconfig.params = {\n\t\t\t\t\t'TIME': layer.params.time\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Manage bbox\n\t\t\tif (layer.bbox) {\n\t\t\t\tconfig.maxExtent = new OpenLayers.Bounds(layer.bbox).transform(this._map.displayProjection, this._map.projection);\n\t\t\t}\n\t\t\tolLayer = new OpenLayers.Layer.WMTS(config);\n\t\t\tbreak;\n\t\tcase \"GEORSS\":\n\t\t\t//olLayer = new OpenLayers.Layer.GeoRSS(layer.name, layer.location, { projection: \"EPSG:4326\" });\t\n\t\t\tolLayer = new OpenLayers.Layer.Vector(layer.name, {\n\t\t\t\tstrategies: [new OpenLayers.Strategy.Fixed()],\n\t\t\t\tprotocol: new OpenLayers.Protocol.HTTP({\n\t\t\t\t\turl: layer.location,\n\t\t\t\t\tformat: new OpenLayers.Format.GeoRSS()\n\t\t\t\t}),\n\t\t\t\tprojection: \"EPSG:4326\"\n\t\t\t});\n\n\t\t\tbreak;\n\t\tcase \"WFS\":\n\t\t\tolLayer = new OpenLayers.Layer.Vector(layer.name, {\n\t\t\t\tstrategies: [new OpenLayers.Strategy.Fixed()],\n\t\t\t\tprotocol: new OpenLayers.Protocol.WFS({\n\t\t\t\t\turl: layer.baseUrl,\n\t\t\t\t\tfeatureType: layer.featureType,\n\t\t\t\t\tfeatureNS: layer.featureNS\n\t\t\t\t}),\n\t\t\t\tprojection: \"EPSG:4326\"\n\t\t\t});\n\t\t\tbreak;\n\t\tcase \"KML\":\n\t\t\tif (layer.data) {\n\t\t\t\tvar kmlFormat = new OpenLayers.Format.KML({\n\t\t\t\t\textractStyles: true,\n\t\t\t\t\textractAttributes: true,\n\t\t\t\t\tmaxDepth: 0\n\t\t\t\t});\n\t\t\t\tvar features = kmlFormat.read(layer.data);\n\t\t\t\tolLayer = new OpenLayers.Layer.Vector(layer.name, {\n\t\t\t\t\tprojection: \"EPSG:4326\"\n\t\t\t\t});\n\t\t\t\tolLayer.addFeatures(features);\n\t\t\t} else if (layer.location) {\n\t\t\t\tolLayer = new OpenLayers.Layer.Vector(layer.name, {\n\t\t\t\t\tstrategies: [new OpenLayers.Strategy.Fixed()],\n\t\t\t\t\tprotocol: new OpenLayers.Protocol.HTTP({\n\t\t\t\t\t\turl: layer.location,\n\t\t\t\t\t\tformat: new OpenLayers.Format.KML({\n\t\t\t\t\t\t\textractStyles: true,\n\t\t\t\t\t\t\textractAttributes: true,\n\t\t\t\t\t\t\tmaxDepth: 0\n\t\t\t\t\t\t})\n\t\t\t\t\t}),\n\t\t\t\t\tprojection: \"EPSG:4326\"\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"FEATURE\":\n\t\tcase \"JSON\":\n\t\tcase \"GEOJSON\":\n\t\t\tolLayer = new OpenLayers.Layer.Vector(layer.name, {\n\t\t\t\t// Use \"canvas\" renderer since \"SVG\" has a bug while rendering features crossing the dateline\n\t\t\t\t// Pros: no more bug. Cons: Less performant\n\t\t\t\t// @see https://github.com/openlayers/openlayers/issues/668\n\t\t\t\trenderers: ['Canvas', 'VML'],\n\t\t\t\tprojection: \"EPSG:4326\"\n\t\t\t});\n\t\t\tif (layer.data) {\n\t\t\t\tvar geojsonFormat = new OpenLayers.Format.GeoJSON();\n\t\t\t\tvar features = geojsonFormat.read(layer.data);\n\t\t\t\tolLayer.addFeatures(features);\n\t\t\t}\n\t}\n\n\tif (olLayer) {\n\n\t\t// Set common options\n\t\tolLayer.attribution = layer.attribution;\n\t\tif (layer.style && this.styles[layer.style]) {\n\t\t\tolLayer.styleMap = this.styles[layer.style];\n\t\t}\n\t\tolLayer.setVisibility(layer.visible);\n\n\t\t// Finally add to map\n\t\tthis._map.addLayer(olLayer);\n\t}\n\n\treturn olLayer;\n}\n\n/**\n * Remove layer from the map engine\n */\nOpenLayersMapEngine.prototype.removeLayer = function(olLayer) {\n\tolLayer.destroy();\n}\n\n/**\n * Subscribe to OpenLayersMap events\n */\nOpenLayersMapEngine.prototype.subscribe = function(name, callback) {\n\tswitch (name) {\n\t\tcase \"init\":\n\t\t\tcallback(this);\n\t\t\tbreak;\n\t\tcase \"navigationModified\":\n\t\t\t// Attach events for navigation change\n\t\t\tthis._map.events.register(\"move\", undefined, callback);\n\t\t\tbreak;\n\t\tcase \"mousedown\":\n\t\tcase \"mouseup\":\n\t\tcase \"mousemove\":\n\t\tcase \"click\":\n\t\tcase \"dblclick\":\n\t\t\tthis._map.events.register(name, undefined, callback, true);\n\t\t\tbreak;\n\t}\n}\n\n/**\n * Subscribe to OpenLayersMap events\n */\nOpenLayersMapEngine.prototype.unsubscribe = function(name, callback) {\n\tswitch (name) {\n\t\tcase \"navigationModified\":\n\t\t\t// Detach events for navigation change\n\t\t\tthis._map.events.unregister(\"move\", undefined, callback);\n\t\t\tbreak;\n\t\tcase \"mousedown\":\n\t\tcase \"mouseup\":\n\t\tcase \"mousemove\":\n\t\tcase \"click\":\n\t\tcase \"dblclick\":\n\t\t\tthis._map.events.unregister(name, undefined, callback, true);\n\t\t\tbreak;\n\t}\n}\n\n\n/**\n * Update the size of the map\n */\nOpenLayersMapEngine.prototype.updateSize = function() {\n\t// Update the resolutions array\n\tthis._map.resolutions = this.computeResolutions(this._map.restrictedExtent);\n\tthis._map.baseLayer.initResolutions();\n\n\t// Then update the size\n\tthis._map.updateSize();\n}\n\n/**\n * Get lon lat from pixel\n */\nOpenLayersMapEngine.prototype.getLonLatFromPixel = function(x, y) {\n\tvar olLonLat = this._map.getLonLatFromPixel(new OpenLayers.Pixel(x, y));\n\tolLonLat = olLonLat.transform(this._map.projection, this._map.displayProjection);\n\treturn [olLonLat.lon, olLonLat.lat];\n}\n\n/**\n * Get pixel from lonlat\n */\nOpenLayersMapEngine.prototype.getPixelFromLonLat = function(lon, lat) {\n\tvar olLonLat = new OpenLayers.LonLat(lon, lat);\n\tolLonLat = olLonLat.transform(this._map.displayProjection, this._map.projection);\n\tvar olPixel = this._map.getPixelFromLonLat(olLonLat);\n\treturn {\n\t\tx: olPixel.x,\n\t\ty: olPixel.y\n\t};\n}\n\n/**\n * Get the current viewport extent\n */\nOpenLayersMapEngine.prototype.getViewportExtent = function() {\n\tvar boundsOrig = this._map.getExtent();\n\tif (boundsOrig) {\n\t\tvar extent = [];\n\t\t//\n\t\tvar bounds = boundsOrig.transform(this._map.projection, this._map.displayProjection);\n\n\t\tvar w = Math.abs(bounds.getWidth());\n\t\tvar h = Math.abs(bounds.getHeight());\n\t\textent[0] = bounds.getCenterLonLat().lon - 0.5 * w;\n\t\textent[1] = bounds.getCenterLonLat().lat - 0.5 * h;\n\t\textent[2] = bounds.getCenterLonLat().lon + 0.5 * w;\n\t\textent[3] = bounds.getCenterLonLat().lat + 0.5 * h;\n\t\treturn extent;\n\t} else {\n\t\treturn null;\n\t}\n}\n\n/**\n * Zoom to the given extent\n */\nOpenLayersMapEngine.prototype.zoomToExtent = function(extent) {\n\tvar bounds = new OpenLayers.Bounds(extent[0], extent[1], extent[2], extent[3]);\n\tbounds.transform(this._map.displayProjection, this._map.projection);\n\tvar center = bounds.getCenterLonLat();\n\tthis._map.setCenter(center, this._map.getZoomForExtent(bounds, true));\n}\n\n\n/**\n * Zoom in\n */\nOpenLayersMapEngine.prototype.zoomIn = function() {\n\tthis._map.zoomIn();\n}\n\n/**\n * Zoom out\n */\nOpenLayersMapEngine.prototype.zoomOut = function() {\n\tthis._map.zoomOut();\n}\n\n/**\n * Remove all features from a layer\n */\nOpenLayersMapEngine.prototype.removeAllFeatures = function(layer) {\n\tlayer.removeAllFeatures();\n}\n\n/**\n * Add a feature on the map\n */\nOpenLayersMapEngine.prototype.addFeature = function(layer, feature) {\n\tvar olFeatures = this._geoJsonFormat.read(MapUtils.fixDateLine(feature));\n\tlayer.addFeatures(olFeatures);\n\tlayer.drawFeature(layer.getFeatureByFid(feature.id), feature.renderHint);\n}\n\n/**\n * Modify the feature style\n */\nOpenLayersMapEngine.prototype.modifyFeatureStyle = function(layer, feature, style) {\n\tvar olFeature = layer.getFeatureByFid(feature.id);\n\tif (olFeature) {\n\t\tolFeature.renderIntent = style;\n\t\tlayer.drawFeature(olFeature, style);\n\t}\n}\n\n/**\n *\tUpdates style for the given feature according to conditional styling from configuration\n *\tif applicable, otherwise return the initial style\n */\nOpenLayersMapEngine.prototype.applyConditionalStyling = function(layer, feature, style) {\n\tvar currentStyle = style;\n\tvar engineStyles = layer.styleMap.styles;\n\tfor ( var x in engineStyles ) {\n\t\tvar engineStyle = engineStyles[x];\n\t\tif ( engineStyle.isApplicable && engineStyle.isApplicable(feature, style) ) {\n\t\t\tcurrentStyle = x;\n\t\t}\n\t}\n\treturn currentStyle;\n}\n\n/**\n * Block the navigation\n */\nOpenLayersMapEngine.prototype.blockNavigation = function(flag) {\n\tif (flag) {\n\t\tthis._map.controls[0].deactivate();\n\t} else {\n\t\tthis._map.controls[0].activate();\n\t}\n}\n\n/**\n * Update a feature\n */\nOpenLayersMapEngine.prototype.updateFeature = function(layer, feature, customFixDateLine) {\n\tif (customFixDateLine) {\n\t\tfeature = customFixDateLine(feature);\n\t} else {\n\t\tfeature = MapUtils.fixDateLine(feature);\n\t}\n\tvar olFeature = layer.getFeatureByFid(feature.id);\n\tlayer.removeFeatures(olFeature);\n\tlayer.addFeatures(this._geoJsonFormat.read(feature));\n}\n\n/**\n * Remove a feature\n */\nOpenLayersMapEngine.prototype.removeFeature = function(layer, feature) {\n\tvar olFeature = layer.getFeatureByFid(feature.id);\n\tlayer.removeFeatures(olFeature);\n}\n\n/**\n * Destroy the map\n */\nOpenLayersMapEngine.prototype.destroy = function() {\n\tthis._map.destroy();\n\tthis.element.className = \"\";\n}\n\nmodule.exports = OpenLayersMapEngine;","var Handler = require('map/handler');\r\nvar Map = require('map/map');\r\n\r\n\r\n/**\r\n * Private variables\r\n */\r\nvar layer;\r\nvar feature;\r\nvar startPoint;\r\nvar mapEngine;\r\nvar coords;\r\nvar started = false;\r\nvar lastClickTime = -1;\r\nvar lastX = -1;\r\nvar lastY = -1;\r\nvar onstop = null;\r\nvar self = null;\r\n\r\n// Called when a double click is detected\r\nfunction finishHandler() {\r\n\t// Remove duplicated point (used for mouse move drawing)\r\n\tcoords.splice(coords.length - 2, 1);\r\n\tself.stop();\r\n}\r\n\r\n// Detect a double-click event. Cannot use browser double-click to avoid multiple point added, and because of problem with OpenLayers and double click\r\nfunction isDoubleClick(event) {\r\n\r\n\tvar clickTime = Date.now();\r\n\r\n\tvar isDoubleClick = (clickTime - lastClickTime) < 250 && Math.abs(event.pageX - lastX) < 1 && Math.abs(event.pageY - lastY) < 1;\r\n\r\n\tlastClickTime = clickTime;\r\n\tlastX = event.pageX;\r\n\tlastY = event.pageY;\r\n\r\n\treturn isDoubleClick;\r\n}\r\n\r\nfunction updateFeature() {\r\n\tfeature.geometry.type = \"Polygon\";\r\n\tfeature.geometry.coordinates = [coords];\r\n\t// If there is any bbox, clear it, it is no longer valid.\r\n\t// Sometimes the map backend can compute the bbox for rendering purposes\r\n\tfeature.bbox = null;\r\n\tlayer.updateFeature(feature);\r\n};\r\n\r\n// Called on a click : add a new point in the polygon\r\nfunction onClick(event) {\r\n\tif (started && event.button == 0) {\r\n\r\n\t\tif (isDoubleClick(event)) {\r\n\t\t\tstarted = false;\r\n\t\t\tsetTimeout(finishHandler, 50);\r\n\t\t} else {\r\n\t\t\tvar point = Map.getLonLatFromEvent(event);\r\n\t\t\tif (coords.length == 0) {\r\n\t\t\t\tcoords.push(point, point, point);\r\n\t\t\t} else {\r\n\t\t\t\t// Update the last point\r\n\t\t\t\tcoords[coords.length - 2] = point;\r\n\t\t\t\t// Duplicate the last point for mouse move update\r\n\t\t\t\tcoords.splice(coords.length - 1, 0, point);\r\n\t\t\t}\r\n\t\t\tupdateFeature();\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// Called when mouse is moved : update the polygon\r\nfunction onMouseMove(event) {\r\n\tif (started && coords.length > 0 && event.button == 0) {\r\n\t\tvar point = Map.getLonLatFromEvent(event);\r\n\t\tcoords[coords.length - 2] = point;\r\n\t\tupdateFeature();\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * Public interface\r\n */\r\nself = new Handler({\r\n\t// Start the handler\r\n\tstart: function(options) {\r\n\t\tmapEngine = Map.getMapEngine();\r\n\r\n\t\t// Create the layer if not already created\r\n\t\tif (options.layer) {\r\n\t\t\tlayer = options.layer;\r\n\t\t\tfeature = options.feature;\r\n\t\t\tcoords = feature.geometry.coordinates[0];\r\n\t\t} else if (!layer) {\r\n\t\t\tcoords = [];\r\n\t\t\tfeature = {\r\n\t\t\t\tid: '0',\r\n\t\t\t\ttype: 'Feature',\r\n\t\t\t\tgeometry: {\r\n\t\t\t\t\ttype: 'Polygon',\r\n\t\t\t\t\tcoordinates: [coords]\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tvar params = {\r\n\t\t\t\tname: \"Draw Area\",\r\n\t\t\t\ttype: \"Feature\",\r\n\t\t\t\tvisible: true,\r\n\t\t\t\tstyle: \"imported\",\r\n\t\t\t\tdata: feature\r\n\t\t\t};\r\n\t\t\tlayer = Map.addLayer(params);\r\n\t\t}\r\n\r\n\t\t// No navigation when drawing a polygon\r\n\t\tmapEngine.blockNavigation(true);\r\n\r\n\t\t// Subscribe to mouse events\r\n\t\tmapEngine.subscribe(\"mousemove\", onMouseMove);\r\n\t\tmapEngine.subscribe(\"mouseup\", onClick);\r\n\r\n\t\tonstop = options.stop;\r\n\r\n\t\t// Prepare mouse listening and reset coordinates\r\n\t\tcoords.length = 0;\r\n\t\tstarted = true;\r\n\t},\r\n\r\n\t// Stop the handler\r\n\tstop: function() {\r\n\t\t// Restore navigation\r\n\t\tmapEngine.blockNavigation(false);\r\n\t\t// Unsubscribe to mouse events\r\n\t\tmapEngine.unsubscribe(\"mousemove\", onMouseMove);\r\n\t\tmapEngine.unsubscribe(\"mouseup\", onClick);\r\n\r\n\t\tif (onstop) {\r\n\t\t\tfeature.geometry.type = \"Polygon\";\r\n\t\t\tfeature.geometry.coordinates = [coords];\r\n\t\t\tonstop();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = self;","var MapUtils = require('map/utils');\n\n/**\n *\tRectangle class allowing to handle WIDE polygon issues\n *\t\n *\tBy adding some points in nominal case\n *\tChanging type to MultiLineString when crossing dateline\n */\nvar Rectangle = function(options) {\n    if ( options.feature ) {\n    \t// Compute bbox from feature\n\n    \tthis.feature = options.feature;\n    \tvar bbox = MapUtils.computeBbox(this.feature.geometry);\n    \tthis.west = bbox[0];\n    \tthis.south = bbox[1];\n    \tthis.east = bbox[2];\n    \tthis.north = bbox[3];\n    \tthis.computeStep();\n    \tthis.updateFeature({type: this.feature.geometry.type});\n    } else {\n    \t// Compute feature from bbox coordinates\n\t    this.west = options.west;\n\t    this.south = options.south;\n\t    this.east = options.east;\n\t    this.north = options.north;\n\t    this.feature = {\n\t    \tid: \"Dynamic rectangle\",\n\t    \ttype: \"Feature\",\n\t    \tgeometry: {}, // Will be computed afterwards\n\t    \tproperties: {}\n\t    }\n\t    this.updateFeature({type: options.type});\n    }\n}\n\n/**\n *\tCompute step for additional points depending if we cross dateline or not\n */\nRectangle.prototype.computeStep = function() {\n\tvar nbSegments = 4;\n\tthis.step = this.west > this.east ? ((180 - this.west) + 180 + this.east)/nbSegments : (this.east - this.west)/nbSegments;\n}\n\n/**\n *\tUpdate feature according to new bbox parameters\n */\nRectangle.prototype.updateFeature = function(options) {\n\tvar type = this.west > this.east ? \"MultiLineString\" : \"Polygon\"; // By default\n\tif ( options && options.type ) {\n\t\ttype = options.type;\n\t}\n\n\t// Update step depending on crossing dateline attribut\n\tthis.computeStep();\n\n\tthis.feature.geometry.type = type;\n\tif ( type == \"MultiLineString\" ) {\n\t\t// MultiLine string\n\t\tthis.feature.geometry.coordinates = [\n\t\t\t[ [ -180, this.north ], [ this.east, this.north ], [ this.east, this.south ], [ -180, this.south ] ],\n\t\t\t[ [ 180, this.north ], [ this.west, this.north ], [ this.west, this.south ], [ 180, this.south] ],\n\t\t\t[ [ -180, this.north ], [ this.west - 360, this.north ], [ this.west - 360, this.south ], [ -180, this.south] ],\n\t\t\t[ [ 180, this.north ], [ this.east + 360, this.north ], [ this.east + 360, this.south ], [ 180, this.south] ]\n\t\t];\n\t} else {\n\t\t// Polygon\n\t    this.feature.geometry.coordinates = [\n\t        [\n\t            [this.west, this.south],\n\t            [MapUtils.normalizeLon(this.west + this.step), this.south],\n\t            [MapUtils.normalizeLon(this.west + this.step * 2), this.south],\n\t            [MapUtils.normalizeLon(this.west + this.step * 3), this.south],\n\t            [this.east, this.south],\n\t            [this.east, this.north],\n\t            [MapUtils.normalizeLon(this.west + this.step * 3), this.north],\n\t            [MapUtils.normalizeLon(this.west + this.step * 2), this.north],\n\t            [MapUtils.normalizeLon(this.west + this.step), this.north],\n\t            [this.west, this.north],\n\t            [this.west, this.south]\n\t        ]\n\t    ];\n\t}\n}\n\nmodule.exports = Rectangle;","var Handler = require('map/handler');\r\nvar Map = require('map/map');\r\nvar MapUtils = require('map/utils');\r\nvar Rectangle = require('map/rectangle');\r\n\r\n/**\r\n * Private variables\r\n */\r\nvar layer;\r\nvar rectangle;\r\nvar feature;\r\nvar startPoint;\r\nvar endPoint;\r\nvar mapEngine;\r\nvar started = false;\r\nvar onstop = null;\r\nvar self = null;\r\n\r\n// Current direction of user's mouse\r\nvar toEast;\r\n\r\n// Used for debug\r\n/*\r\nvar params = {\r\n\tname: \"Points\",\r\n\ttype: \"Feature\",\r\n\tvisible: true,\r\n\tstyle: \"imported\"\r\n};\r\nvar pointsLayer = Map.addLayer(params);\r\n\r\n// Adds additional points to polygon to handle better wide rectangles\r\nvar addPoints = function(polygon) {\r\n\r\n\tvar minX = polygon[0][0][0];\r\n\tvar minY = polygon[0][0][1];\r\n\tvar maxX = polygon[0][2][0];\r\n\tvar maxY = polygon[0][2][1];\r\n\r\n\tconsole.log(\"===\");\r\n\tvar oldOne= polygon[0].slice(0);\r\n\tconsole.log(oldOne);\r\n\r\n\tvar step = Math.abs((maxX - minX) / 3);\r\n\tpolygon[0].splice(1, 0, [minX + step, minY]);\r\n\tpolygon[0].splice(2, 0, [minX + 2*step, minY]);\r\n\tpolygon[0].splice(5, 0, [minX + 2*step, maxY]);\r\n\tpolygon[0].splice(6, 0, [minX + step, maxY]);\r\n\r\n\tpointsLayer.clear();\r\n\r\n\tfor ( var i=0; i<polygon[0].length; i++ ) {\r\n\t\tvar pFeature = {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tgeometry: {\r\n\t\t\t\ttype: 'Point',\r\n\t\t\t\tcoordinates: polygon[0][i]\r\n\t\t\t},\r\n\t\t\tproperties: {}\r\n\t\t};\r\n\t\tpointsLayer.addFeature(pFeature);\r\n\t}\r\n}\r\n*/\r\n\r\n/**\r\n *\tCompute if user moves mouse in east direction or not\r\n */\r\nvar updateToEast = function(start, end) {\r\n\tif ( rectangle.feature.bbox ) {\r\n\t\tvar pCurrent = {\r\n\t\t\tlat: end[1], \r\n\t\t\tlon: end[0]\r\n\t\t};\r\n\t\tvar p2 = {\r\n\t\t\tlat: end[1],\r\n\t\t\tlon: start[0]\r\n\t\t};\r\n\r\n\t\tvar distanceDelta = 2007000;\r\n\t\tif ( MapUtils.distanceBetween(pCurrent, p2) < distanceDelta && rectangle.step < 30 ) {\r\n\t\t\tvar seg1 = {\r\n\t\t\t\tlat: -1,\r\n\t\t\t\tlon: start[0]\r\n\t\t\t};\r\n\t\t\tvar seg2 = {\r\n\t\t\t\tlat: 1,\r\n\t\t\t\tlon: start[0]\r\n\t\t\t};\r\n\t\t\tvar d = MapUtils.crossTrackDistanceBetween(pCurrent, seg1, seg2);\r\n\t\t\tif ( d > 0 ) {\r\n\t\t\t\ttoEast = true;\r\n\t\t\t} else {\r\n\t\t\t\ttoEast = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn toEast;\r\n}\r\n\r\n// Update the feature used to represent the rectangle\r\nfunction updateFeature(start, end) {\r\n\r\n\tif ( !start || !end )\r\n\t\treturn;\r\n\r\n\tif ( updateToEast(start, end) ) {\r\n\t\t// Nominal case, user drags to east\r\n\t\tminX = start[0];\r\n\t\tmaxX = end[0];\r\n\t} else {\r\n\t\t// Inverse start/end if user moves to west\r\n\t\tminX = end[0];\r\n\t\tmaxX = start[0];\r\n\t}\r\n\r\n\tvar minY = Math.min(start[1], end[1]);\r\n\tvar maxY = Math.max(start[1], end[1]);\r\n\t\r\n\trectangle.feature.bbox = [ minX, minY, maxX, maxY ];\r\n\r\n\trectangle.west = minX;\r\n\trectangle.east = maxX;\r\n\trectangle.north = maxY;\r\n\trectangle.south = minY;\r\n\trectangle.updateFeature();\r\n\r\n\t// addPoints(rectangle.feature.geometry.coordinates);\r\n\r\n\t// No dateline fix when feature crosses dateline\r\n\tvar noDateLineFixCallback = function(feature) {\r\n\t\treturn feature;\r\n\t}\r\n\tlayer.updateFeature(rectangle.feature, feature.geometry.type == \"MultiLineString\" ? noDateLineFixCallback : null);\r\n};\r\n\r\n// Called when left mouse button is pressed : start drawing the rectangle\r\nfunction onMouseDown(event) {\r\n\tif (event.button == 0) {\r\n\t\tstartPoint = Map.getLonLatFromEvent(event);\r\n\t\tendPoint = Map.getLonLatFromEvent(event);\r\n\t\tupdateFeature(startPoint, startPoint);\r\n\t\tstarted = true;\r\n\t}\r\n};\r\n\r\n// Called when mouse is moved : update the rectangle\r\nfunction onMouseMove(event) {\r\n\tif (started && event.button == 0) {\r\n\t\t// Check if previous point has passed by dateline\r\n\t\tendPoint = Map.getLonLatFromEvent(event);\r\n\t\tupdateFeature(startPoint, endPoint);\r\n\t}\r\n};\r\n\r\n// Called when left mouse button is release : end drawing the rectangle\r\nfunction onMouseUp(event) {\r\n\tif (started && event.button == 0) {\r\n\t\tendPoint = Map.getLonLatFromEvent(event);\r\n\t\tupdateFeature(startPoint, endPoint);\r\n\r\n\t\t// end drawing\r\n\t\tself.stop();\r\n\t\tstarted = false;\r\n\t}\r\n};\r\n\r\n/**\r\n * Public interface\r\n */\r\nself = new Handler({\r\n\t// Start the handler\r\n\tstart: function(options) {\r\n\t\tmapEngine = Map.getMapEngine();\r\n\r\n\t\t// Create the layer if not already created\r\n\t\tif (options.layer) {\r\n\t\t\tlayer = options.layer;\r\n\t\t\tfeature = options.feature;\r\n\t\t\trectangle = new Rectangle({\r\n\t\t\t\tfeature: feature\r\n\t\t\t});\r\n\t\t} else if (!layer) {\r\n\t\t\tcoords = [];\r\n\r\n\t\t\trectangle = new Rectangle({\r\n\t\t\t\twest: 0,\r\n\t\t\t\teast: 1,\r\n\t\t\t\tsouth: 0,\r\n\t\t\t\tnorth: 1\r\n\t\t\t});\r\n\r\n\t\t\tvar params = {\r\n\t\t\t\tname: \"Draw Area\",\r\n\t\t\t\ttype: \"Feature\",\r\n\t\t\t\tvisible: true,\r\n\t\t\t\tstyle: \"imported\",\r\n\t\t\t\tdata: feature\r\n\t\t\t};\r\n\t\t\tlayer = Map.addLayer(params);\r\n\t\t}\r\n\r\n\t\t// No navigation when drawing a rectangle\r\n\t\tmapEngine.blockNavigation(true);\r\n\r\n\t\t// Subscribe to mouse events\r\n\t\tmapEngine.subscribe(\"mousedown\", onMouseDown);\r\n\t\tmapEngine.subscribe(\"mousemove\", onMouseMove);\r\n\t\tmapEngine.subscribe(\"mouseup\", onMouseUp);\r\n\r\n\t\tonstop = options.stop;\r\n\t},\r\n\r\n\t// Stop the handler\r\n\tstop: function() {\r\n\t\t// Restore navigation\r\n\t\tmapEngine.blockNavigation(false);\r\n\r\n\t\t// Unsubscribe to mouse events\r\n\t\tmapEngine.unsubscribe(\"mousedown\", onMouseDown);\r\n\t\tmapEngine.unsubscribe(\"mousemove\", onMouseMove);\r\n\t\tmapEngine.unsubscribe(\"mouseup\", onMouseUp);\r\n\r\n\t\tif (onstop) {\r\n\t\t\tonstop();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = self;","var Configuration = require('configuration');\r\nvar Handler = require('map/handler');\r\nvar Map = require('map/map');\r\nvar MapUtils = require('map/utils');\r\nvar SearchResults = require('searchResults/model/searchResults');\r\n\r\n\r\n/**\r\n * Private variables\r\n */\r\n// The current picked features\r\nvar pickedFeatures = [];\r\n// The layers to be excluded on picking (TODO: very hacky way.. think how to centralize it)\r\nvar excludedLayers = [];\r\n// The layer to pick\r\nvar featureCollections = [];\r\n// The index when using stack picking\r\nvar stackPickingIndex = -1;\r\n// The map engine\r\nvar mapEngine;\r\n// Needed to detect click\r\nvar prevX, prevY, prevTime;\r\n// Needed to clear stack when selection is changed from another way\r\nvar inPicking = false;\r\n// The picking radius\r\nvar radius = -1.0;\r\n\r\n/**\r\n * Private methods\r\n */\r\n\r\n/**\r\n * Check if the point is inside the given ring\r\n */\r\nvar pointInRing = function(point, ring) {\r\n\tvar nvert = ring.length;\r\n\tif (ring[0][0] == ring[nvert - 1][0] && ring[0][1] == ring[nvert - 1][1]) {\r\n\t\tnvert--;\r\n\t}\r\n\tvar inPoly = false;\r\n\r\n\tvar j = nvert - 1;\r\n\tfor (var i = 0; i < nvert; j = i++) {\r\n\t\tif (((ring[i][1] > point[1]) != (ring[j][1] > point[1])) &&\r\n\t\t\t(point[0] < (ring[j][0] - ring[i][0]) * (point[1] - ring[i][1]) / (ring[j][1] - ring[i][1]) + ring[i][0])) {\r\n\t\t\tinPoly = !inPoly;\r\n\t\t}\r\n\t}\r\n\treturn inPoly;\r\n};\r\n\r\n/**\r\n * Compute line-circle intersection\r\n */\r\nvar lineCircleIntersection = function(p1, p2, center, radius) {\r\n\tvar dx = p2[0] - p1[0];\r\n\tvar dy = p2[1] - p1[1];\r\n\r\n\tvar lx = p1[0] - center[0];\r\n\tvar ly = p1[1] - center[1];\r\n\r\n\tvar a = dx * dx + dy * dy;\r\n\tvar b = 2 * (lx * dx + ly * dy);\r\n\tvar c = lx * lx + ly * ly - radius * radius;\r\n\r\n\tvar discriminant = b * b - 4 * a * c;\r\n\tif (discriminant <= 0) {\r\n\t\treturn false;\r\n\t}\r\n\tdiscriminant = Math.sqrt(discriminant);\r\n\tvar t1 = (-b - discriminant) / (2 * a);\r\n\tvar t2 = (-b + discriminant) / (2 * a);\r\n\treturn ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1));\r\n};\r\n\r\n/**\r\n * Check if a point is inside a line\r\n */\r\nvar pointInLine = function(point, coords) {\r\n\t// Compute radius\r\n\tif (radius < 0.0) {\r\n\t\tvar pixel = Map.getPixelFromLonLat(point[0], point[1]);\r\n\t\tvar ul = Map.getLonLatFromPixel(pixel.x + 1, pixel.y + 1);\r\n\t\tradius = 1.5 * Math.sqrt((ul[0] - point[0]) * (ul[0] - point[0]) + (ul[1] - point[1]) * (ul[1] - point[1]));\r\n\t}\r\n\r\n\tfor (var i = 0; i < coords.length - 1; i++) {\r\n\t\tif (lineCircleIntersection(coords[i], coords[i + 1], point, radius)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n/**\r\n * Check if the point is inside the given geometry\r\n */\r\nvar pointInGeometry = function(point, geometry) {\r\n\tswitch (geometry.type) {\r\n\t\tcase \"MultiPolygon\":\r\n\t\t\tvar inside = false;\r\n\t\t\tfor (var i = 0; i < geometry.coordinates.length && !inside; i++) {\r\n\t\t\t\tinside = pointInRing(point, geometry.coordinates[i][0]);\r\n\t\t\t}\r\n\t\t\treturn inside;\r\n\t\tcase \"Polygon\":\r\n\t\t\treturn pointInRing(point, geometry.coordinates[0]);\r\n\t\tcase \"LineString\":\r\n\t\t\treturn pointInLine(point, geometry.coordinates);\r\n\t\tcase \"MultiLineString\":\r\n\t\t\tvar inside = false;\r\n\t\t\tfor (var i = 0; i < geometry.coordinates.length && !inside; i++) {\r\n\t\t\t\tinside = pointInLine(point, geometry.coordinates[i]);\r\n\t\t\t}\r\n\t\t\treturn inside;\r\n\t\tdefault:\r\n\t\t\treturn false;\r\n\t}\r\n};\r\n\r\n\r\n/**\r\n * Get the feature from a point : test if the point is inside the footprint\r\n */\r\nvar getFeaturesFromPoint = function(lonlat) {\r\n\r\n\tradius = -1;\r\n\r\n\tvar features = [];\r\n\tfor (var i = 0; i < featureCollections.length; i++) {\r\n\t\tvar fc = featureCollections[i];\r\n\t\tif ( excludedLayers.indexOf(fc._footprintLayer) >= 0 )\r\n\t\t\tcontinue;\r\n\r\n\t\tfor (var j = 0; j < fc.features.length; j++) {\r\n\t\t\t// Fix dateline to be able to pick dateline-crossing features\r\n\t\t\t// since its original geometry isn't modified\r\n\t\t\tvar feature = MapUtils.fixDateLine(fc.features[j]);\r\n\t\t\tif (pointInGeometry(lonlat, feature.geometry)) {\r\n\t\t\t\tfeature._featureCollection = fc;\r\n\t\t\t\tfeatures.push(feature);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn features;\r\n};\r\n\r\n/** \r\n *\tTest if a new selection is equal to the previous selection\r\n */\r\nvar isSelectionEqual = function(newSelection) {\r\n\tif (pickedFeatures.length == newSelection.length) {\r\n\r\n\t\tfor (var i = 0; i < pickedFeatures.length; i++) {\r\n\t\t\tif (pickedFeatures[i] != newSelection[i])\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t} else\r\n\t\treturn false;\r\n};\r\n\r\n/**\r\n *\tHelper function to sort features by date\r\n */\r\nvar sortFeatureByDate = function(a, b) {\r\n\treturn new Date(Configuration.getMappedProperty(b, \"start\")) - new Date(Configuration.getMappedProperty(a, \"start\"));\r\n}\r\n\r\n/**\r\n * Call when the user click on the map\r\n */\r\nvar mapClickHandler = function(event) {\r\n\tif (event.button != 0) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Check there is data to select\r\n\tif (featureCollections.length == 0)\r\n\t\treturn;\r\n\r\n\t// Check that we are on a click\r\n\tvar dx = Math.abs(event.pageX - prevX);\r\n\tvar dy = Math.abs(event.pageY - prevY);\r\n\tvar dt = Date.now() - prevTime;\r\n\tif (dx > 1 || dy > 1 || dt > 500) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar lonlat = Map.getLonLatFromEvent(event);\r\n\tif (lonlat) {\r\n\t\tvar features = getFeaturesFromPoint(lonlat);\r\n\r\n\t\t// Pre-sort by date the selection\r\n\t\tfeatures.sort(sortFeatureByDate);\r\n\r\n\t\tinPicking = true;\r\n\r\n\t\tif (isSelectionEqual(features)) {\r\n\r\n\t\t\tstackPickingIndex++;\r\n\r\n\t\t\tif (stackPickingIndex == pickedFeatures.length) {\r\n\t\t\t\tstackPickingIndex = -1;\r\n\t\t\t\tMap.trigger(\"pickedFeatures\", pickedFeatures, featureCollections);\r\n\t\t\t} else {\r\n\t\t\t\tMap.trigger(\"pickedFeatures\", [pickedFeatures[stackPickingIndex]], featureCollections);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tpickedFeatures = features;\r\n\t\t\tstackPickingIndex = -1;\r\n\t\t\tMap.trigger(\"pickedFeatures\", pickedFeatures, featureCollections);\r\n\r\n\t\t}\r\n\r\n\t\tinPicking = false;\r\n\t}\r\n};\r\n\r\n/**\r\n * Call when the user pressed the left mouse button\r\n */\r\nfunction onMouseDown(event) {\r\n\tif (event.button == 0) {\r\n\t\tprevX = event.pageX;\r\n\t\tprevY = event.pageY;\r\n\t\tprevTime = Date.now();\r\n\t}\r\n};\r\n\r\n/**\r\n * Clear stack when selection is changed\r\n */\r\nfunction clearStack() {\r\n\tif (!inPicking) {\r\n\t\tpickedFeatures = [];\r\n\t}\r\n};\r\n\r\n\r\n/**\r\n * Public interface\r\n */\r\nmodule.exports = new Handler({\r\n\r\n\t/**\r\n\t * Initialize the select handler\r\n\t */\r\n\tinitialize: function(options) {\r\n\t\t//\tlayer = options.layer;\r\n\t},\r\n\r\n\t/**\r\n\t * Add a feature collection to the selectHandler\r\n\t */\r\n\taddFeatureCollection: function(fc) {\r\n\t\tfeatureCollections.push(fc);\r\n\t},\r\n\r\n\t/**\r\n\t * Remove a feature collection from the selectHandler\r\n\t */\r\n\tremoveFeatureCollection: function(fc) {\r\n\t\tthis.setPickable(fc._footprintLayer, true); // Remove it from excludedLayers array just in case\r\n\t\tvar i = featureCollections.indexOf(fc);\r\n\t\tif (i >= 0) {\r\n\t\t\tfeatureCollections.splice(i, 1);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t *\tSet the given layer(not featureCollection) pickable\r\n\t */\r\n\tsetPickable: function(layer, isPickable) {\r\n\t\tif ( isPickable ) {\r\n\t\t\tvar i = excludedLayers.indexOf(layer);\r\n\t\t\tif (i >= 0) {\r\n\t\t\t\texcludedLayers.splice(i, 1);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\texcludedLayers.push(layer);\t\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Start the handler\r\n\t */\r\n\tstart: function() {\r\n\r\n\t\tmapEngine = Map.getMapEngine();\r\n\r\n\t\t// Click is not used because OpenLayers is messing up with click when navigation is active\r\n\t\tmapEngine.subscribe('mousedown', onMouseDown);\r\n\t\tmapEngine.subscribe('mouseup', mapClickHandler);\r\n\r\n\t\tSearchResults.on('selectFeatures', clearStack);\r\n\t\tSearchResults.on('unselectFeatures', clearStack);\r\n\r\n\t},\r\n\r\n\t/**\r\n\t * Stop the handler\r\n\t */\r\n\tstop: function() {\r\n\t\tmapEngine.unsubscribe('mousedown', onMouseDown);\r\n\t\tmapEngine.unsubscribe('mouseup', mapClickHandler);\r\n\t}\r\n});","var Vector3d = require('map/vector3d');\r\n\r\nvar toRadians = function(num) {\r\n\treturn num * Math.PI / 180;\r\n}\r\n\r\n/**\r\n * MapUtils module\r\n */\r\nmodule.exports = {\r\n\r\n\tearthRadius: 6371e3,\r\n\r\n\t/**\r\n\t * Normalize longitude to always be betwwen -180 and 180\r\n\t */\r\n\tnormalizeLon: function(lon) {\r\n\t\twhile (lon > 180)\r\n\t\t\tlon -= 360;\r\n\t\twhile (lon < -180)\r\n\t\t\tlon += 360;\r\n\t\treturn lon;\r\n\t},\r\n\r\n\t/**\r\n\t * Compute the bbox of a geometry\r\n\t */\r\n\tcomputeBbox: function(geometry) {\r\n\t\t//list of array of coordinates from which we have to compute the extent bbox\r\n\t\tvar coordsList = [];\r\n\t\tswitch (geometry.type) {\r\n\t\t\tcase \"Point\":\r\n\t\t\t\tvar pointCoords = geometry.coordinates;\r\n\t\t\t\treturn [pointCoords[0], pointCoords[1], pointCoords[0], pointCoords[1]];\r\n\t\t\tcase \"MultiPoint\":\r\n\t\t\t\tcoordsList.push(geometry.coordinates);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"Polygon\":\r\n\t\t\t\tcoordsList.push(geometry.coordinates[0]);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"MultiPolygon\":\r\n\t\t\t\tvar numOuterRings = geometry.coordinates.length;\r\n\t\t\t\tfor (var j = 0; j < numOuterRings; j++) {\r\n\t\t\t\t\tcoordsList.push(geometry.coordinates[j][0]);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"LineString\":\r\n\t\t\t\tcoordsList.push(geometry.coordinates);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"MultiLineString\":\r\n\t\t\t\tvar numOuterRings = geometry.coordinates.length;\r\n\t\t\t\tfor (var j = 0; j < numOuterRings; j++) {\r\n\t\t\t\t\tcoordsList.push(geometry.coordinates[j]);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t//if there is nothing to compute then just return\r\n\t\tif (coordsList.length == 0)\r\n\t\t\treturn;\r\n\r\n\r\n\t\tvar minX = 10000;\r\n\t\tvar minY = 10000;\r\n\t\tvar maxX = -10000;\r\n\t\tvar maxY = -10000\r\n\r\n\t\tfor (var j = 0; j < coordsList.length; j++) {\r\n\t\t\tvar coords = coordsList[j];\r\n\t\t\tfor (var i = 0; i < coords.length; i++) {\r\n\t\t\t\tminX = Math.min(minX, coords[i][0]);\r\n\t\t\t\tminY = Math.min(minY, coords[i][1]);\r\n\t\t\t\tmaxX = Math.max(maxX, coords[i][0]);\r\n\t\t\t\tmaxY = Math.max(maxY, coords[i][1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [minX, minY, maxX, maxY];\r\n\t},\r\n\r\n\t/**\r\n\t * Compute the bbox of a feature and set it as a property\r\n\t */\r\n\tcomputeExtent: function(feature) {\r\n\t\tif (feature.bbox)\r\n\t\t\treturn;\r\n\t\tfeature.bbox = this.computeBbox(feature.geometry);\r\n\t},\r\n\r\n\t/**\r\n\t * Tesselate the feature to follow great-circle\r\n\t */\r\n\ttesselateGreatCircle: function(feature) {\r\n\r\n\t\t// Tesselate polygon to follow great circle\r\n\t\t// TODO : holes are not managed\r\n\t\tvar geometry = feature.geometry;\r\n\t\tswitch (geometry.type) {\r\n\t\t\tcase \"Polygon\":\r\n\t\t\t\tgeometry.coordinates[0] = this.tesselateGreatCircleCoordinates(geometry.coordinates[0]);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"MultiPolygon\":\r\n\t\t\t\tfor (var i = 0; i < geometry.coordinates.length; i++) {\r\n\t\t\t\t\tgeometry.coordinates[i][0] = this.tesselateGreatCircleCoordinates(geometry.coordinates[i][0]);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"LineString\":\r\n\t\t\t\tgeometry.coordinates = this.tesselateGreatCircleCoordinates(geometry.coordinates);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"MultiLineString\":\r\n\t\t\t\tfor (var i = 0; i < geometry.coordinates.length; i++) {\r\n\t\t\t\t\tgeometry.coordinates[i] = this.tesselateGreatCircleCoordinates(geometry.coordinates[i]);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t *\tCheck if array of coordinates crossing the dateline\r\n\t */\r\n\tcrossDateLine: function(coords) {\r\n\t\tvar posc = [];\r\n\t\tvar negc = [];\r\n\t\tfor (var n = 0; n < coords.length - 1; n++) {\r\n\t\t\tvar x1 = coords[n][0];\r\n\t\t\tvar x2 = coords[n + 1][0];\r\n\r\n\t\t\tif (Math.abs(x1 - x2) > 180)\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t/**\r\n\t * Fix dateline\r\n\t */\r\n\tfixDateLine: function(feature) {\r\n\r\n\t\t// Fix dateline if needed\r\n\t\tvar crossDateLine = false;\r\n\t\tvar geometry = feature.geometry;\r\n\t\tswitch (geometry.type) {\r\n\t\t\tcase \"Polygon\":\r\n\t\t\t\tcrossDateLine = this.crossDateLine(geometry.coordinates[0]);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"MultiPolygon\":\r\n\t\t\t\tvar allCoords = [];\r\n\t\t\t\tfor (var i = 0; i < geometry.coordinates.length; i++) {\r\n\t\t\t\t\tcrossDateLine |= this.crossDateLine(geometry.coordinates[i][0]);\r\n\t\t\t\t\tallCoords = allCoords.concat(geometry.coordinates[i][0]);\r\n\t\t\t\t}\r\n\t\t\t\t// NGEO-1863: Check if dataline is crossed between polygons\r\n\t\t\t\t// NB: Sometimes server splits polygon crossing dateline\r\n\t\t\t\tcrossDateLine |= this.crossDateLine(allCoords);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"LineString\":\r\n\t\t\t\tcrossDateLine = this.crossDateLine(geometry.coordinates);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"MultiLineString\":\r\n\t\t\t\tfor (var i = 0; i < geometry.coordinates.length; i++) {\r\n\t\t\t\t\tcrossDateLine |= this.crossDateLine(geometry.coordinates[i]);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (crossDateLine) {\r\n\t\t\treturn this.splitFeature(feature);\r\n\t\t} else {\r\n\t\t\treturn feature;\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t/**\r\n\t *\tSplits feature's geometry into MultiPolygon which fixes the date line issue\r\n\t *\t\r\n\t *\t@return\r\n\t *\t\tNew feature with splitted geometry\r\n\t */\r\n\tsplitFeature: function(feature) {\r\n\t\tvar geometry = feature.geometry;\r\n\t\tvar featureCopy = {\r\n\t\t\tid: feature.id,\r\n\t\t\ttype: \"Feature\",\r\n\t\t\tgeometry: {},\r\n\t\t\tproperties: feature.properties\r\n\t\t};\r\n\t\tswitch (geometry.type) {\r\n\t\t\tcase \"Polygon\":\r\n\t\t\t\tvar out = this.fixDateLineCoords(geometry.coordinates[0]);\r\n\t\t\t\tfeatureCopy.geometry.type = \"MultiPolygon\";\r\n\t\t\t\tfeatureCopy.geometry.coordinates = [\r\n\t\t\t\t\t[out[0]],\r\n\t\t\t\t\t[out[1]]\r\n\t\t\t\t];\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"MultiPolygon\":\r\n\t\t\t\tvar dateLineCoords = [];\r\n\t\t\t\tfor (var i = 0; i < geometry.coordinates.length; i++) {\r\n\t\t\t\t\tvar out = this.fixDateLineCoords(geometry.coordinates[i][0]);\r\n\t\t\t\t\tdateLineCoords.push([out[0]], [out[1]]);\r\n\t\t\t\t}\r\n\t\t\t\tfeatureCopy.geometry.type = \"MultiPolygon\";\r\n\t\t\t\tfeatureCopy.geometry.coordinates = dateLineCoords;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"LineString\":\r\n\t\t\t\tfeatureCopy.geometry.type = \"MultiLineString\";\r\n\t\t\t\tfeatureCopy.geometry.coordinates = this.fixDateLineCoords(geometry.coordinates);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"MultiLineString\":\r\n\t\t\t\tvar dateLineCoords = [];\r\n\t\t\t\tfor (var i = 0; i < geometry.coordinates.length; i++) {\r\n\t\t\t\t\tvar out = this.fixDateLineCoords(geometry.coordinates[i]);\r\n\t\t\t\t\tdateLineCoords.push(out[0], out[1]);\r\n\t\t\t\t}\r\n\t\t\t\tfeatureCopy.geometry.type = \"MultiLineString\";\r\n\t\t\t\tfeatureCopy.geometry.coordinates = dateLineCoords;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Copy intern 3D property too..\r\n\t\tif ( geometry._bucket )\r\n\t\t \tfeatureCopy.geometry._bucket = geometry._bucket;\r\n\t\t\r\n\t\treturn featureCopy;\r\n\t},\r\n\r\n\t/**\r\n\t * Fix date line on coordinates\r\n\t */\r\n\tfixDateLineCoords: function(coords) {\r\n\r\n\t\tvar posc = [];\r\n\t\tvar negc = [];\r\n\t\tfor (var n = 0; n < coords.length; n++) {\r\n\t\t\tvar coord = [coords[n][0], coords[n][1]];\r\n\t\t\tif (coord[0] < 0) {\r\n\t\t\t\tcoord[0] += 360;\r\n\t\t\t}\r\n\t\t\tposc.push(coord);\r\n\t\t\tnegc.push([coord[0] - 360, coord[1]]);\r\n\t\t}\r\n\r\n\t\treturn [posc, negc];\r\n\t},\r\n\r\n\t/**\r\n\t * Tesselate coordinates to follow great circle\r\n\t */\r\n\ttesselateGreatCircleCoordinates: function(coords) {\r\n\r\n\t\tvar output = [];\r\n\t\tfor (var i = 0; i < coords.length - 1; i++) {\r\n\t\t\toutput.push(coords[i]);\r\n\t\t\tthis.tesselateGreatCircleLine(coords[i], coords[i + 1], output);\r\n\t\t}\r\n\r\n\t\toutput.push(coords[coords.length - 1]);\r\n\r\n\t\treturn output;\r\n\t},\r\n\r\n\t/**\r\n\t * Tesselate an edge (point1,point2) to follow great circle\r\n\t */\r\n\ttesselateGreatCircleLine: function(point1, point2, output) {\r\n\r\n\t\tvar lat1 = point1[1];\r\n\t\tvar lon1 = point1[0];\r\n\t\tvar lat2 = point2[1];\r\n\t\tvar lon2 = point2[0];\r\n\t\tlat1 = lat1 * (Math.PI / 180);\r\n\t\tlon1 = lon1 * (Math.PI / 180);\r\n\t\tlat2 = lat2 * (Math.PI / 180);\r\n\t\tlon2 = lon2 * (Math.PI / 180);\r\n\t\tvar d = 2 * Math.asin(Math.sqrt(Math.pow((Math.sin((lat1 - lat2) / 2)), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow((Math.sin((lon1 - lon2) / 2)), 2)));\r\n\t\tvar numsegs = Math.floor(d * 6371.0 / 200.0);\r\n\t\tvar f = 0.0;\r\n\t\tfor (var i = 0; i < numsegs - 1; i++) {\r\n\t\t\tf += 1.0 / numsegs;\r\n\t\t\tvar A = Math.sin((1 - f) * d) / Math.sin(d);\r\n\t\t\tvar B = Math.sin(f * d) / Math.sin(d);\r\n\t\t\tvar x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);\r\n\t\t\tvar y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);\r\n\t\t\tvar z = A * Math.sin(lat1) + B * Math.sin(lat2);\r\n\t\t\tvar latr = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\r\n\t\t\tvar lonr = Math.atan2(y, x);\r\n\t\t\tvar lat = latr * (180 / Math.PI);\r\n\t\t\tvar lon = lonr * (180 / Math.PI);\r\n\r\n\t\t\toutput.push([lon, lat]);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t *\tParse url extracting all the parameters which respecting key=value\r\n\t *\tEx: http://base_url?key1=val1&key2=val2\r\n\t *\r\n\t *\tReturns a dictionary containing parameters + BASEURL\r\n\t */\r\n\tparseUrl: function(url) {\r\n\t\tvar parsed = {};\r\n\t\tvar params = url.split(/\\?|\\&/);\r\n\t\tparsed[\"BASEURL\"] = params[0];\r\n\t\t_.each(params, function(param) {\r\n\t\t\tvar kv = param.split(\"=\");\r\n\t\t\tif (kv.length == 2)\r\n\t\t\t\tparsed[kv[0].toUpperCase()] = kv[1];\r\n\t\t});\r\n\r\n\t\treturn parsed;\r\n\t},\r\n\r\n\t/**\r\n\t *\tGet WMS/WMTS layer name from url\r\n\t */\r\n\tgetLayerName: function(url) {\r\n\t\tvar parsed = this.parseUrl(url);\r\n\t\tif ( !parsed['SERVICE'] ) {\r\n\t\t\tconsole.warn(\"Url \" + url + \" hasn't got a SERVICE parameter\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tvar layerTag = parsed['SERVICE'].toUpperCase() == 'WMS' ? 'LAYERS' : 'LAYER';\r\n\t\treturn parsed[layerTag];\r\n\t},\r\n\r\n\t/**\r\n\t *\tCreate WMS/WMTS layer from url\r\n\t *\tNot really appropriate here, move it ?\r\n\t */\r\n\tcreateWmsLayerFromUrl: function(url) {\r\n\r\n\t\tvar parsed = this.parseUrl(url);\r\n\t\t\r\n\t\t// TODO: Check SRS --> must be 4326 ?\r\n\t\tvar layerTag = parsed['SERVICE'].toUpperCase() == 'WMS' ? 'LAYERS' : 'LAYER';\r\n\t\tvar wmsLayer = {\r\n\t\t\ttype: parsed['SERVICE'],\r\n\t\t\tbaseUrl: parsed[\"BASEURL\"],\r\n\t\t\tname: parsed[layerTag],\r\n\t\t\ttitle: parsed[layerTag],\r\n\t\t\tparams: {\r\n\t\t\t\tformat: parsed['FORMAT'] ? decodeURIComponent(parsed['FORMAT']) : 'image/png',\r\n\t\t\t\tstyle: parsed['STYLE'],\r\n\t\t\t\ttime: parsed['TIME'] ? decodeURIComponent(parsed['TIME']) : null\r\n\t\t\t}\r\n\t\t};\r\n\t\tif ( parsed['SERVICE'].toUpperCase() == 'WMTS' ) {\r\n\t\t\twmsLayer.params.matrixSet = parsed['TILEMATRIXSET'];\r\n\t\t\twmsLayer.params.layer = parsed[layerTag];\r\n\t\t} else {\r\n\t\t\twmsLayer.params.layers = parsed[layerTag];\r\n\t\t}\r\n\t\treturn wmsLayer;\r\n\t},\r\n\r\n\t/**\r\n\t *\tThe following part is extracted from http://www.movable-type.co.uk/scripts/latlong.html\r\n\t *\t(c) Chris Veness 2011-2015\r\n\t *\tMIT Licence\r\n\t */\r\n\r\n\t/**\r\n\t *\tConvert the given lat/lon to Vector3 object\r\n\t */\r\n\ttoVector: function(latLon) {\r\n\t\tvar phi = toRadians(latLon.lat);\r\n\t\tvar lambda = toRadians(latLon.lon);\r\n\r\n\t\t// Right-handed vector: x -> 0째E,0째N; y -> 90째E,0째N, z -> 90째N\r\n\t\tvar x = Math.cos(phi) * Math.cos(lambda);\r\n\t\tvar y = Math.cos(phi) * Math.sin(lambda);\r\n\t\tvar z = Math.sin(phi);\r\n\t\treturn new Vector3d(x,y,z);\r\n\t},\r\n\r\n\t/**\r\n\t * Great circle obtained by heading on given bearing from the given lat/lon\r\n\t *\r\n\t * Direction of vector is such that initial bearing vector b = c  p.\r\n\t *\r\n\t * @param   {number}   bearing - Compass bearing in degrees.\r\n\t * @returns {Vector3d} Normalised vector representing great circle.\r\n\t *\r\n\t * @example\r\n\t *   var p1 = new LatLon(53.3206, -1.7297);\r\n\t *   var gc = p1.greatCircle(96.0); // gc.toString(): [-0.794,0.129,0.594]\r\n\t */\r\n\tgreatCircle: function(lat, lon, bearing) {\r\n\t\tvar phi = toRadians(lat);\r\n\t\tvar lambda = toRadians(lon);\r\n\t\tvar theta = toRadians(Number(bearing));\r\n\r\n\t\tvar x =  Math.sin(lambda) * Math.cos(theta) - Math.sin(phi) * Math.cos(lambda) * Math.sin(theta);\r\n\t\tvar y = -Math.cos(lambda) * Math.cos(theta) - Math.sin(phi) * Math.sin(lambda) * Math.sin(theta);\r\n\t\tvar z =  Math.cos(phi) * Math.sin(theta);\r\n\t\treturn new Vector3d(x, y, z);\r\n\t},\r\n\r\n\t/**\r\n\t *\tDistance between to points on earth\r\n\t *\t@param {Object} p1 : Geo-point {lat: int, lon: int}\r\n\t *\t@param {Object} p2 : Geo-point {lat: int, lon: int}\r\n\t *\t@param {number} radius : Earth radius in meters\r\n\t *\t@returns\r\n\t *\t\tDistance between to points in same units as radius\r\n\t */\r\n\tdistanceBetween: function(p1, p2, radius) {\r\n\t    // if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');\r\n\t\tradius = (radius === undefined) ? this.earthRadius : Number(radius);\r\n\r\n\t\tvar v1 = this.toVector(p1);\r\n\t\tvar v2 = this.toVector(p2);\r\n\t\tvar delta = v1.angleTo(v2);\r\n\t\tvar d = delta * radius;\r\n\t\treturn d;\r\n\t},\r\n\r\n\tcrossTrackDistanceBetween: function(latLon, pathStart, pathEnd, radius) {\r\n\t    radius = (radius === undefined) ? this.earthRadius : Number(radius);\r\n\r\n\t    var p = this.toVector(latLon);\r\n\r\n\t    // Great circle defined by two points\r\n\t    // console.log(\"pathStart\", pathStart);\r\n\t    var v1 = this.toVector(pathStart);\r\n\t    // console.log(\"v1\", v1);\r\n\t    // console.log(\"pathEnd\", pathEnd);\r\n\t    var v2 = this.toVector(pathEnd);\r\n\t    // console.log(\"v2\", v2);\r\n\t    var gc = v1.cross(v2);\r\n\t    // console.log(gc);\r\n\r\n\t    var alpha = gc.angleTo(p, p.cross(gc)); // (signed) angle between point & great-circle normal vector\r\n\t    alpha = alpha<0 ? -Math.PI/2 - alpha : Math.PI/2 - alpha; // (signed) angle between point & great-circle\r\n\r\n\t    var d = alpha * radius;\r\n\r\n\t    return d;\r\n\t},\r\n\r\n\tdistanceToSegment: function(latLon, point1, point2, radius) {\r\n\t    var v0 = this.toVector(latLon),\r\n\t    \tv1 = this.toVector(point1),\r\n\t    \tv2 = this.toVector(point2);\r\n\r\n\t    // Dot product p10p12 tells us if p0 is on p2 side of p1, similarly for p20p21\r\n\t    var p10 = v0.minus(v1), p12 = v2.minus(v1);\r\n\t    var p20 = v0.minus(v2), p21 = v1.minus(v2);\r\n\r\n\t    var extent1 = p10.dot(p12);\r\n\t    var extent2 = p20.dot(p21);\r\n\r\n\t    var withinExtent = extent1>=0 && extent2>=0;\r\n\r\n\t    if (withinExtent) {\r\n\t        // closer to segment than to its endpoints, use cross-track distance\r\n\t        var d = Math.abs(this.crossTrackDistanceBetween(latLon, point1, point2, radius));\r\n\t    } else {\r\n\t        // beyond segment extent, take smaller of distances to endpoints\r\n\t        var d1 = this.distanceBetween(latLon, point1, radius);\r\n\t        var d2 = this.distanceBetween(latLon, point2, radius);\r\n\t        var d = Math.min(d1, d2);\r\n\t    }\r\n\r\n\t    return d;\r\n\t}\r\n}","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Vector handling functions                                          (c) Chris Veness 2011-2016  */\n/*                                                                                   MIT Licence  */\n/* www.movable-type.co.uk/scripts/geodesy/docs/module-vector3d.html                               */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n'use strict';\n\n\n/**\n * Library of 3-d vector manipulation routines.\n *\n * In a geodesy context, these vectors may be used to represent:\n *  - n-vector representing a normal to point on Earth's surface\n *  - earth-centered, earth fixed vector ( Gades p-vector)\n *  - great circle normal to vector (on spherical earth model)\n *  - motion vector on Earth's surface\n *  - etc\n *\n * Functions return vectors as return results, so that operations can be chained.\n * @example var v = v1.cross(v2).dot(v3) //  v1v2v3\n *\n * @module vector3d\n */\n\n\n/**\n * Creates a 3-d vector.\n *\n * The vector may be normalised, or use x/y/z values for eg height relative to the sphere or\n * ellipsoid, distance from earth centre, etc.\n *\n * @constructor\n * @param {number} x - X component of vector.\n * @param {number} y - Y component of vector.\n * @param {number} z - Z component of vector.\n */\nfunction Vector3d(x, y, z) {\n    // allow instantiation without 'new'\n    if (!(this instanceof Vector3d)) return new Vector3d(x, y, z);\n\n    this.x = Number(x);\n    this.y = Number(y);\n    this.z = Number(z);\n}\n\n\n/**\n * Adds supplied vector to this vector.\n *\n * @param   {Vector3d} v - Vector to be added to this vector.\n * @returns {Vector3d} Vector representing sum of this and v.\n */\nVector3d.prototype.plus = function(v) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);\n};\n\n\n/**\n * Subtracts supplied vector from this vector.\n *\n * @param   {Vector3d} v - Vector to be subtracted from this vector.\n * @returns {Vector3d} Vector representing difference between this and v.\n */\nVector3d.prototype.minus = function(v) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);\n};\n\n\n/**\n * Multiplies this vector by a scalar value.\n *\n * @param   {number}   x - Factor to multiply this vector by.\n * @returns {Vector3d} Vector scaled by x.\n */\nVector3d.prototype.times = function(x) {\n    x = Number(x);\n\n    return new Vector3d(this.x * x, this.y * x, this.z * x);\n};\n\n\n/**\n * Divides this vector by a scalar value.\n *\n * @param   {number}   x - Factor to divide this vector by.\n * @returns {Vector3d} Vector divided by x.\n */\nVector3d.prototype.dividedBy = function(x) {\n    x = Number(x);\n\n    return new Vector3d(this.x / x, this.y / x, this.z / x);\n};\n\n\n/**\n * Multiplies this vector by the supplied vector using dot (scalar) product.\n *\n * @param   {Vector3d} v - Vector to be dotted with this vector.\n * @returns {number} Dot product of this and v.\n */\nVector3d.prototype.dot = function(v) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    return this.x*v.x + this.y*v.y + this.z*v.z;\n};\n\n\n/**\n * Multiplies this vector by the supplied vector using cross (vector) product.\n *\n * @param   {Vector3d} v - Vector to be crossed with this vector.\n * @returns {Vector3d} Cross product of this and v.\n */\nVector3d.prototype.cross = function(v) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    var x = this.y*v.z - this.z*v.y;\n    var y = this.z*v.x - this.x*v.z;\n    var z = this.x*v.y - this.y*v.x;\n\n    return new Vector3d(x, y, z);\n};\n\n\n/**\n * Negates a vector to point in the opposite direction\n *\n * @returns {Vector3d} Negated vector.\n */\nVector3d.prototype.negate = function() {\n    return new Vector3d(-this.x, -this.y, -this.z);\n};\n\n\n/**\n * Length (magnitude or norm) of this vector\n *\n * @returns {number} Magnitude of this vector.\n */\nVector3d.prototype.length = function() {\n    return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);\n};\n\n\n/**\n * Normalizes a vector to its unit vector\n *  if the vector is already unit or is zero magnitude, this is a no-op.\n *\n * @returns {Vector3d} Normalised version of this vector.\n */\nVector3d.prototype.unit = function() {\n    var norm = this.length();\n    if (norm == 1) return this;\n    if (norm == 0) return this;\n\n    var x = this.x/norm;\n    var y = this.y/norm;\n    var z = this.z/norm;\n\n    return new Vector3d(x, y, z);\n};\n\n\n/**\n * Calculates the angle between this vector and supplied vector.\n *\n * @param   {Vector3d} v\n * @param   {Vector3d} [vSign] - If supplied (and out of plane of this and v), angle is signed +ve if\n *     this->v is clockwise looking along vSign, -ve in opposite direction (otherwise unsigned angle).\n * @returns {number} Angle (in radians) between this vector and supplied vector.\n */\nVector3d.prototype.angleTo = function(v, vSign) {\n    if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');\n\n    var sin罐 = this.cross(v).length();\n    var cos罐 = this.dot(v);\n\n    if (vSign !== undefined) {\n        if (!(vSign instanceof Vector3d)) throw new TypeError('vSign is not Vector3d object');\n        // use vSign as reference to get sign of sin罐\n        sin罐 = this.cross(v).dot(vSign)<0 ? -sin罐 : sin罐;\n    }\n\n    return Math.atan2(sin罐, cos罐);\n};\n\n\n/**\n * Rotates this point around an axis by a specified angle.\n *\n * @param   {Vector3d} axis - The axis being rotated around.\n * @param   {number}   theta - The angle of rotation (in radians).\n * @returns {Vector3d} The rotated point.\n */\nVector3d.prototype.rotateAround = function(axis, theta) {\n    if (!(axis instanceof Vector3d)) throw new TypeError('axis is not Vector3d object');\n\n    // en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n    // en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\n    var p1 = this.unit();\n    var p = [ p1.x, p1.y, p1.z ]; // the point being rotated\n    var a = axis.unit();          // the axis being rotated around\n    var s = Math.sin(theta);\n    var c = Math.cos(theta);\n    // quaternion-derived rotation matrix\n    var q = [\n        [ a.x*a.x*(1-c) + c,     a.x*a.y*(1-c) - a.z*s, a.x*a.z*(1-c) + a.y*s ],\n        [ a.y*a.x*(1-c) + a.z*s, a.y*a.y*(1-c) + c,     a.y*a.z*(1-c) - a.x*s ],\n        [ a.z*a.x*(1-c) - a.y*s, a.z*a.y*(1-c) + a.x*s, a.z*a.z*(1-c) + c     ],\n    ];\n    // multiply q  p\n    var qp = [ 0, 0, 0 ];\n    for (var i=0; i<3; i++) {\n        for (var j=0; j<3; j++) {\n            qp[i] += q[i][j] * p[j];\n        }\n    }\n    var p2 = new Vector3d(qp[0], qp[1], qp[2]);\n    return p2;\n    // qv en.wikipedia.org/wiki/Rodrigues'_rotation_formula...\n};\n\n\n/**\n * String representation of vector.\n *\n * @param   {number} [precision=3] - Number of decimal places to be used.\n * @returns {string} Vector represented as [x,y,z].\n */\nVector3d.prototype.toString = function(precision) {\n    var p = (precision === undefined) ? 3 : Number(precision);\n\n    var str = '[' + this.x.toFixed(p) + ',' + this.y.toFixed(p) + ',' + this.z.toFixed(p) + ']';\n\n    return str;\n};\n\nmodule.exports = Vector3d;","/**\r\n * Background widget module\r\n */\r\n\r\nvar Map = require('map/map');\r\nvar ngeoWidget = require('ui/widget');\r\n\r\n/**\r\n * The background widget\r\n */\r\nvar backbroundWidget;\r\n\r\n/**\r\n * Function to change the background when selected\r\n */\r\nvar changeBackground = function() {\r\n\tvar layer = $(this).closest('fieldset').find('input[name=\"background-choice\"]:checked').data(\"layer\")\r\n\tMap.setBackgroundLayer(layer);\r\n\tbackbroundWidget.ngeowidget(\"hide\");\r\n};\r\n\r\nvar BackgroundWidget = function(dsa) {\r\n\t// Add the background widget to the data services area\r\n\tdsa.append('<div id=\"backgroundWidget\"/>');\r\n\r\n\t// Build background layers panel \r\n\tthis.container = $('<fieldset data-role=\"controlgroup\"></fieldset>');\r\n\tvar bgLayers = Map.backgroundLayers;\r\n\tfor (var i = 0; i < bgLayers.length; i++) {\r\n\t\tthis.buildHtml(bgLayers[i]);\r\n\t}\r\n\r\n\tbackbroundWidget = $(\"#backgroundWidget\")\r\n\t\t.append(this.container).ngeowidget({\r\n\t\t\tactivator: '#background'\r\n\t\t});\r\n\r\n\tvar self = this;\r\n\tMap.on('backgroundLayerAdded', function(layer) {\r\n\t\tself.buildHtml(layer);\r\n\t\t$(backgroundWidget).trigger(\"create\");\r\n\t})\r\n\tMap.on('backgroundLayerRemoved', function(layer) {\r\n\t\tself.container.find('input').each(function() {\r\n\t\t\tif ($(this).data('layer') == layer) {\r\n\t\t\t\t$(this).parent().remove();\r\n\t\t\t}\r\n\t\t});\r\n\t\t$(backgroundWidget).trigger('create');\r\n\t});\r\n\tMap.on('backgroundLayerSelected', function(layer) {\r\n\t\tvar input = _.find(self.container.find('input'), function(input) {\r\n\t\t\treturn $(input).data(\"layer\") == layer;\r\n\t\t});\r\n\t\t$(input).prop(\"checked\", true).checkboxradio(\"refresh\");\r\n\t});\r\n\r\n\t// Select the background used from the preferences unless select the first one\r\n\tvar selector = '#' + Map.getBackgroundLayer().id;\r\n\t//check the background layer radio box \r\n\t$(dsa).find(selector).prop('checked', 'checked').checkboxradio(\"refresh\");\r\n};\r\n\r\n/**\r\n *\tBuild the HTML for background layer\r\n */\r\nBackgroundWidget.prototype.buildHtml = function(layer) {\r\n\r\n\t// Add radio button + attribute callback on change\r\n\tvar isChecked = layer.visible ? 'checked=\"checked\"' : \"\";\r\n\tvar id = layer.id ? layer.id : layer.name.replace(/\\s+/g,\"_\");\r\n\tvar input = $('<input id=\"' + id + '\" type=\"radio\" name=\"background-choice\" '+ isChecked +' />')\r\n\t\t.data(\"layer\", layer)\r\n\t\t.change(changeBackground);\r\n\r\n\t// Build the label for input and add it to the group\r\n\t$('<label for=\"'+id+'\" data-mini=\"true\">' + layer.name + '</label>')\r\n\t\t.append(input)\r\n\t\t.appendTo(this.container);\r\n};\r\n\r\nmodule.exports = BackgroundWidget","/**\r\n * Layers widget module\r\n */\r\n\r\nvar Map = require('map/map');\r\nvar ngeoWidget = require('ui/widget');\r\nvar SelectHandler = require('map/selectHandler');\r\n\r\n/**\r\n * Callback called when a layer is checked\r\n */\r\nvar layerCheckedCallback = function() {\r\n\tvar layer = $(this).data('layer');\r\n\tvar isVisible = !layer.params.visible;\r\n\tlayer.setVisible(isVisible);\t\r\n};\r\n\r\nvar LayersWidget = function(element) {\r\n\r\n\tvar $layersWidget = $('<div id=\"layersWidget\"/>').appendTo(element);\r\n\r\n\t// Build overlays panel\r\n\tthis.container = $(\"<fieldset data-role='controlgroup'></fieldset>\");\r\n\r\n\tvar layers = Map.layers;\r\n\r\n\t// Update checkboxes when layers visibility has changed\r\n\tMap.on(\"visibility:changed\", function(layer) {\r\n\t\tvar $input = null;\r\n\t\t// Fins input according to layer\r\n\t\tself.container.find('input').each(function() {\r\n\t\t\tif ($(this).data('layer') == layer) {\r\n\t\t\t\t$input = $(this);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tvar isVisible = layer.params.visible;\r\n\t\tif ($input) {\r\n\t\t\tif ( isVisible ) {\r\n\t\t\t\t$input.prop('checked', 'checked').checkboxradio(\"refresh\");\r\n\t\t\t} else {\r\n\t\t\t\t$input.removeProp('checked').checkboxradio(\"refresh\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t// FIXME: nothing to do here..\r\n\t\tSelectHandler.setPickable(layer, isVisible);\r\n\t});\r\n\r\n\tfor (var i = 0; i < layers.length; i++) {\r\n\t\tthis.buildHTML(layers[i]);\r\n\t}\r\n\tthis.container.appendTo($layersWidget);\r\n\r\n\tvar self = this;\r\n\t// Callback when a layer is added on the map\r\n\tMap.on('layerAdded', function(layer) {\r\n\t\tif ( layer.params.type != \"Browses\" && layer.params.name.indexOf(\"Footprints\") == -1 ) {\r\n\t\t\tself.buildHTML(layer);\r\n\t\t\t$layersWidget.trigger('create');\r\n\t\t}\r\n\t});\r\n\r\n\t// Callback when a layer is removed from the map\r\n\tMap.on('layerRemoved', function(layer) {\r\n\t\tif ( layer.type != \"Browses\" && layer.params.name.indexOf(\"Footprints\") == -1 ) {\r\n\t\t\tself.container.find('input').each(function() {\r\n\t\t\t\tif ($(this).data('layer') == layer) {\r\n\t\t\t\t\t$(this).parent().remove();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t$layersWidget.trigger('create');\r\n\t\t}\r\n\t});\r\n\r\n\tthis.$el = $layersWidget;\r\n};\r\n\r\n/**\r\n * Build the HTML for a layer\r\n */\r\nLayersWidget.prototype.buildHTML = function(layer) {\r\n\r\n\tif ( layer.params.name.indexOf('Footprints') == -1 ) {\r\n\t\t// Build the input\r\n\t\tvar input = $(\"<input type='checkbox'\" + (layer.params.visible ? \"checked='checked'\" : \"\") + \">\")\r\n\t\t\t.data('layer', layer);\r\n\r\n\t\t// Callback called when the input is changed\r\n\t\tinput.change(layerCheckedCallback);\r\n\r\n\t\t// Build the label for input and add it to the group\r\n\t\t$(\"<label data-mini='true'>\" + (layer.params.title ? layer.params.title : layer.params.name) + \"</label>\")\r\n\t\t\t.prepend(input)\r\n\t\t\t.appendTo(this.container);\r\n\t}\r\n};\r\n\r\n/**\r\n *\tRefresh visibility of layers\r\n */\r\nLayersWidget.prototype.refresh = function() {\r\n\t// Not the best solution ever.. satisfying for now\r\n\tthis.container.empty();\r\n\tvar layers = Map.layers;\r\n\tfor (var i = 0; i < layers.length; i++) {\r\n\t\tthis.buildHTML(layers[i]);\r\n\t}\r\n\tthis.$el.trigger('create');\r\n\r\n};\r\n\r\nmodule.exports = LayersWidget;","/**\r\n * MapPopup module\r\n */\r\n\r\nvar GlobalEvents = require('globalEvents');\r\nvar Logger = require('logger');\r\nvar Configuration = require('configuration');\r\nvar Map = require('map/map');\r\nvar DownloadOptions = require('search/model/downloadOptions');\r\nvar SimpleDataAccessRequest = require('dataAccess/model/simpleDataAccessRequest');\r\nvar DataAccessWidget = require('dataAccess/widget/dataAccessWidget');\r\nvar SearchResults = require('searchResults/model/searchResults');\r\nvar Utils = require('map/utils');\r\nvar UserPrefs = require('userPrefs');\r\nvar MultipleBrowseWidget = require('searchResults/widget/multipleBrowseWidget');\r\n\r\nvar MapPopup = function(container) {\r\n\r\n\t/**\r\n\t * Private variables\r\n\t */\r\n\tvar element;\r\n\tvar parentElement;\r\n\tvar arrow;\r\n\tvar products = null;\r\n\tvar isOpened = false;\r\n\tvar advancedActivated = UserPrefs.get(\"Advanced info state\") ? UserPrefs.get(\"Advanced info state\") : false;\r\n\r\n\telement = $(\r\n\t\t'<div class=\"widget-content mapPopup\">\\\r\n\t\t\t<div id=\"mpText\"></div>\\\r\n\t\t\t<div id=\"mpButtons\" data-mini=\"true\" data-role=\"controlgroup\" data-type=\"horizontal\"></div>\\\r\n\t\t</div>');\r\n\r\n\t// Wrap with the parent div for widget\r\n\telement.wrap(\"<div id='mapPopup' class='widget'></div>\");\r\n\tparentElement = element.parent();\r\n\r\n\t// Add buttons for some simple actions\r\n\r\n\t// Info\r\n\tvar btn = $(\"<button id='info' data-icon='info' data-iconpos='notext' data-role='button' data-inline='true' data-mini='true'>Information</button>\")\r\n\t\t.appendTo(element.find('#mpButtons'))\r\n\t\t.click(function() {\r\n\t\t\tif ($(this).parent().hasClass('ui-btn-active')) {\r\n\t\t\t\tadvancedActivated = false;\r\n\t\t\t\tbuildContent(advancedActivated);\r\n\t\t\t\t$(this).parent().removeClass('ui-btn-active ui-focus');\r\n\t\t\t} else {\r\n\t\t\t\tadvancedActivated = true;\r\n\t\t\t\tbuildContent(advancedActivated);\r\n\t\t\t\t$(this).parent().addClass('ui-btn-active');\r\n\t\t\t}\r\n\t\t\tUserPrefs.save(\"Advanced info state\", advancedActivated);\r\n\t\t});\r\n\r\n\t// Select\r\n\tbtn = $(\"<button data-icon='check' data-iconpos='notext' data-role='button' data-inline='true' data-mini='true'>Select product</button>\")\r\n\t\t.appendTo(element.find('#mpButtons'))\r\n\t\t.click(function() {\r\n\t\t\t\r\n\t\t\tvar isSelected = $(this).parent().hasClass('ui-btn-active');\r\n\t\t\t// Update button's layout\r\n\t\t\tif (isSelected) {\r\n\t\t\t\t$(this).parent().removeClass('ui-btn-active ui-focus');\r\n\t\t\t} else {\r\n\t\t\t\t$(this).parent().addClass('ui-btn-active');\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i = 0; i < products.length; i++) {  \r\n\t\t\t\tvar p = products[i];  \r\n\t\t\t\tif (isSelected) {  \r\n\t\t\t\t\tp._featureCollection.unselect([p]);\r\n\t\t\t\t} else {  \r\n\t\t\t\t\tp._featureCollection.select([p]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t// Browse\r\n\tbtn = $(\"<button data-icon='browse' data-iconpos='notext' data-role='button' data-inline='true' data-mini='true'>Display browse</button>\")\r\n\t\t.appendTo(element.find(\"#mpButtons\"))\r\n\t\t.click(function() {\r\n\t\t\tvar isSelected = $(this).parent().hasClass('ui-btn-active');\r\n\t\t\t// Update button's layout\r\n\t\t\tif (isSelected) {\r\n\t\t\t\t$(this).parent().removeClass('ui-btn-active ui-focus');\r\n\t\t\t} else {\r\n\t\t\t\t$(this).parent().addClass('ui-btn-active');\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i = 0; i < products.length; i++) {\r\n\t\t\t\tvar p = products[i];\r\n\t\t\t\tif (isSelected) {\r\n\t\t\t\t\tp._featureCollection.hideBrowses([p]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tp._featureCollection.showBrowses([p]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t// Multiple browse management\r\n\tbtn = $(\"<button data-icon='browse-multiple' data-iconpos='notext' data-role='button' data-inline='true' data-mini='true'>Multiple browse management</button>\")\r\n\t\t.appendTo(element.find(\"#mpButtons\"))\r\n\t\t.click(function() {\r\n\t\t\tMultipleBrowseWidget.open({\r\n\t\t\t\tfeature: products[0],\r\n\t\t\t\tfeatureCollection: products[0]._featureCollection\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t// DAR\r\n\tbtn = $(\"<button data-icon='save' data-iconpos='notext' data-role='button' data-inline='true' data-mini='true'>Retrieve product</button>\")\r\n\t\t.appendTo(element.find('#mpButtons'))\r\n\t\t.click(function() {\r\n\r\n\t\t\tvar allowedProducts = [];\r\n\t\t\tfor (var i = 0; i < products.length; i++) {\r\n\t\t\t\tif (products[i]._featureCollection.downloadAccess) {\r\n\t\t\t\t\tallowedProducts.push(products[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (allowedProducts.length > 0) {\r\n\t\t\t\tSimpleDataAccessRequest.initialize();\r\n\t\t\t\tSimpleDataAccessRequest.setProducts(allowedProducts);\r\n\r\n\t\t\t\tDataAccessWidget.open(SimpleDataAccessRequest);\r\n\t\t\t} else {\r\n\t\t\t\tLogger.inform(\"Cannot download product : missing permissions.\");\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t// Shopcart\r\n\tbtn = $(\"<button data-icon='shop' data-iconpos='notext' data-role='button' data-inline='true' data-mini='true'>Add to shopcart</button>\")\r\n\t\t.appendTo(element.find('#mpButtons'))\r\n\t\t.click(function() {\r\n\t\t\tGlobalEvents.trigger('addToShopcart', products);\r\n\t\t});\r\n\r\n\tparentElement.appendTo(container);\r\n\tparentElement.trigger(\"create\");\r\n\r\n\tparentElement.hide();\r\n\r\n\tvar self = this;\r\n\tMap.on('pickedFeatures', function(pickedFeatures) {\r\n\t\tself.openOrCloseDialog(pickedFeatures);\r\n\t});\r\n\r\n\t/**\r\n\t* When we hightligth feature, update information linked to those features if the dialod is open.\r\n\t* Otherwise , do nothing\r\n\t*/\r\n\tMap.on('highlightFeatures', function(highlightedFeatures) {\r\n\t\tself.openOrCloseDialog(highlightedFeatures);\r\n\t});\r\n\r\n\t/**\r\n\t* When we unselect features, just close the window\r\n\t*/\r\n\tMap.on('unselectFeatures', function() {\r\n\t\t// Set timeout to be sure that this event will trigger after highlight\r\n\t\t// Used in case when user clicked on not highlighted but checked feature in table\r\n\t\t// So basically he unchecks and highlights the feature -> popup shouldn't be displayed\r\n\t\tsetTimeout(function() {\r\n\t\t\tself.close();\r\n\t\t}, 1);\r\n\t});\r\n\r\n\t/*Map.on('extent:change', function() {\r\n\t\tself.close();\r\n\t});\r\n\r\n\t/**\r\n\t * Private methods\r\n\t */\r\n\r\n\t/**\r\n\t\tGet data from a path\r\n\t */\r\n\tvar getData = function(product, path) {\r\n\t\tvar names = path.split('.');\r\n\t\tvar obj = product;\r\n\t\tfor (var i = 0; obj && i < names.length - 1; i++) {\r\n\t\t\tobj = obj[names[i]];\r\n\t\t}\r\n\t\tif (obj && obj.hasOwnProperty(names[names.length - 1])) {\r\n\t\t\treturn obj[names[names.length - 1]];\r\n\t\t} else {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t\tBuild the content of the popup from the given product\r\n\t */\r\n\tvar buildContent = function(adv) {\r\n\t\tvar content;\r\n\r\n\t\t// Hide by default\r\n\t\telement.find('#mpButtons button[data-icon=\"browse-multiple\"]').parent().hide();\r\n\r\n\t\tif (products.length == 1) {\r\n\t\t\tvar product = products[0];\r\n\t\t\t// Build product title according to NGEO-1969\r\n\t\t\tvar productTitle = Configuration.getMappedProperty(product, \"sensor\") + \" / \"\r\n\t\t\t\t\t\t\t+ Configuration.getMappedProperty(product, \"operationalMode\") + \" / \"\r\n\t\t\t\t\t\t\t+ Configuration.getMappedProperty(product, \"productType\")\r\n\t\t\tcontent = '<p><b>' + productTitle + '</b></p>';\r\n\t\t\tif (adv) {\r\n\t\t\t\tvar columnDefs = Configuration.data.tableView.columnsDef;\r\n\t\t\t\tfor (var i = 0; i < columnDefs.length; i++) {\r\n\t\t\t\t\tif (columnDefs[i].sTitle != 'Product') {\r\n\t\t\t\t\t\tvar value = Configuration.getFromPath(product, columnDefs[i].mData);\r\n\t\t\t\t\t\tif ( columnDefs[i].sTitle == 'Download options' && value ) {\r\n\t\t\t\t\t\t\t// HACK: Skip it for now, we should store it somewhere, or WEBS should send it for us\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t// Snippet to handle download options depending on current search area\r\n\t\t\t\t\t\t\t\tvar downloadOptions = new DownloadOptions();\r\n\t\t\t\t\t\t\t\tdownloadOptions.initFromUrl(value);\r\n\t\t\t\t\t\t\t\tvar value = downloadOptions.getParameters();\r\n\t\t\t\t\t\t\t\tif ( !value.length )\r\n\t\t\t\t\t\t\t\t\tvalue = \"No download options\";\r\n\t\t\t\t\t\t\t*/\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\t\tcontent += '<p>' + columnDefs[i].sTitle + ': <span title=\"'+value+'\">' + value + '</span></p>';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcontent += '<p>Date: ' + Configuration.getMappedProperty(product, \"start\") + '</p>';\r\n\t\t\t}\r\n\r\n\t\t\t// Show only if product has multiple browses\r\n\t\t\tvar browses = Configuration.getMappedProperty(product, \"browses\");\r\n\t\t\tif ( browses && browses.length > 1 ) {\r\n\t\t\t\telement.find('#mpButtons button[data-icon=\"browse-multiple\"]').parent().show();\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tcontent = products.length + \" products picked.<br>Click again to cycle through products.\";\r\n\t\t\tif (adv) {\r\n\t\t\t\tcontent += \"<p>Products: </p>\";\r\n\t\t\t\tfor (var i = 0; i < products.length; i++) {\r\n\t\t\t\t\tcontent += \"<p title='\"+ products[i].id +\"'>\" + products[i].id + \"</p>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tvar hasSelected = _.find(products, function(feature) { return feature._featureCollection.isSelected(feature); });\r\n\t\tif ( hasSelected ) {\r\n\t\t\telement.find('#mpButtons button[data-icon=\"check\"]').parent().addClass('ui-btn-active');\r\n\t\t} else {\r\n\t\t\telement.find('#mpButtons button[data-icon=\"check\"]').parent().removeClass('ui-btn-active');\r\n\t\t}\r\n\r\n\t\tvar hasBrowses = _.find(products, function(feature) { return feature._browseShown; });\r\n\t\tif ( hasBrowses ) {\r\n\t\t\telement.find('#mpButtons button[data-icon=\"browse\"]').parent().addClass('ui-btn-active');\r\n\t\t} else {\r\n\t\t\telement.find('#mpButtons button[data-icon=\"browse\"]').parent().removeClass('ui-btn-active');\r\n\t\t}\r\n\r\n\t\t// NGEO-1770: No retrieve button if selection contains at least one planned product or product url doesn't exist\r\n\t\tvar hasPlannedOrNoProductUrl = _.find(products, function(feature) {\r\n\t\t\treturn Configuration.getMappedProperty(feature, \"status\", null) == \"PLANNED\" ||\r\n\t\t\t\t!Configuration.getMappedProperty(feature, \"productUrl\");\r\n\t\t});\r\n\t\telement.find('#mpButtons button[data-icon=\"save\"]').button(hasPlannedOrNoProductUrl ? 'disable' : 'enable');\r\n\t\tif ( advancedActivated ) {\r\n\t\t\telement.find('#mpButtons button[data-icon=\"info\"]').parent().addClass('ui-btn-active');\r\n\t\t}\r\n\t\telement.find('#mpText').html(content);\r\n\t};\r\n\r\n\r\n\t/**\r\n\t\tOpen the popup\r\n\t */\r\n\tthis.open = function(highlightedFeatures) {\r\n\r\n\t\tproducts = highlightedFeatures;\r\n\r\n\t\t// Clean-up previous state\r\n\t\t$('#info').parent().removeClass('ui-btn-active ui-focus');\r\n\r\n\t\tbuildContent(advancedActivated);\r\n\r\n\t\tparentElement.fadeIn();\r\n\r\n\t\tisOpened = true;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t\tClose the popup\r\n\t */\r\n\tthis.close = function() {\r\n\r\n\t\tif (isOpened) {\r\n\t\t\tparentElement.stop(true).fadeOut();\r\n\t\t\tisOpened = false;\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t/**\r\n\t* Depending on the feature list, if empty, close the dialog, otherwise open the dialog and update content\r\n\t*/\r\n\tthis.openOrCloseDialog = function(featuresList) {\r\n\t\tif (featuresList.length == 0) {\r\n\t\t\tthis.close();\r\n\t\t} else {\r\n\t\t\tthis.open(featuresList);\r\n\t\t}\r\n\t};\r\n\r\n\tSearchResults.on('reset:features', this.close, this);\r\n\r\n};\r\n\r\nmodule.exports = MapPopup;","var Map = require('map/map');\r\nvar LayersWidget = require('map/widget/layers');\r\nvar BackgroundWidget = require('map/widget/background');\r\nvar UserPrefs = require('userPrefs');\r\n\r\nvar mode2D = UserPrefs.get('Map mode') ? UserPrefs.get('Map mode') == '2d' : true;\r\n\r\nmodule.exports = function(dsa) {\r\n\r\n\tthis.layersWidget = new LayersWidget(dsa);\r\n\r\n\t// Create widget\r\n\tthis.layersWidget.$el.ngeowidget({\r\n\t\tactivator: '#layers'\r\n\t});\r\n\r\n\tnew BackgroundWidget(dsa);\r\n\r\n\t$(\"#zoomIn\").click(function() {\r\n\t\tMap.zoomIn();\r\n\t});\r\n\t$(\"#zoomOut\").click(function() {\r\n\t\tMap.zoomOut();\r\n\t});\r\n\t$(\"#home\").click(function() {\r\n\t\tMap.zoomToMaxExtent();\r\n\t});\r\n\r\n\t$(\"#switch\").click(function() {\r\n\t\tmode2D = !mode2D;\r\n\t\tif (!Map.switchMapEngine(mode2D ? '2d' : '3d')) {\r\n\t\t\t// Create a pop-up to warn the user\r\n\t\t\t$('<div><p>3D map is not available because WebGL is not supported by your browser, see <a href=\"http://get.webgl.org/\">here</a> for more details.</p></div>')\r\n\t\t\t\t.appendTo('#mapContainer')\r\n\t\t\t\t.popup()\r\n\t\t\t\t.popup('open');\r\n\t\t\tmode2D = true;\r\n\t\t\t// Switch back to 2D\r\n\t\t\tMap.switchMapEngine('2d');\r\n\t\t}\r\n\t});\r\n\r\n\t// TEMPO : use draw button to launch drawing, useful for testing\r\n\t/*\tdsa.find(\"#draw\").click( function(event) {\r\n\t\t\tvar $this = $(this);\r\n\t\t\t$this.toggleClass('toggle');\r\n\t\t\tmapEngine = Map.getMapEngine();\r\n\t\t\tif ( $this.hasClass('toggle') ) {\r\n\t\t\t\tRectangleHandler.start({\r\n\t\t\t\t\tstop: function() {\r\n\t\t\t\t\t\t$this.toggleClass('toggle');\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tRectangleHandler.stop();\r\n\t\t\t}\r\n\t\t});*/\r\n\r\n};"]}